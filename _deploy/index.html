
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>JEEN's techlog</title>
  <meta name="author" content="Jeen Lee">
  
  <meta name="Generator" content="Jekyll & Octopress (http://octopress.org)">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jeen.github.io/">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="JEEN's techlog" type="application/atom+xml">
  

<!--Fonts from Google's Web font directory at http://google.com/webfonts -->
<link href='//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
<link href='//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/build/all-d6d9ba8d8ed93ba1e6156209462b4f6b.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-27958809-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


  

   
  <link href="/octopress-favicon.png" rel="icon">
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">JEEN's techlog</a></h1>
  
    <h2>Yet Another JEEN's Blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jeen.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/archives/">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/2013/07/17/solr-vs-elasticsearch-part-6-user-and-dev-communities-compared/">[번역] Solr vs. ElasticSearch: Part 6 – User &amp; Dev Communities Compared</a>

</h1>

    
      <p class="meta">
        








  



<time datetime="2013-07-17T00:47:24+00:00" pubdate data-updated="true">Jul 17<span>th</span>, 2013</time>
         &bull; <a rel="bookmark" href="/2013/07/17/solr-vs-elasticsearch-part-6-user-and-dev-communities-compared/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><h1>Solr vs. ElasticSearch: Part 6 – User &amp; Dev Communities Compared</h1>

<p>January 22, 2013 by Rafał Kuć</p>

<p>One of the questions after my talk during the recent ApacheCon EU was what I thought about the communities of the two search engines I was comparing. Not surprisingly, this is also a question we often address in our consulting engagements.  As a part of our Apache Solr vs ElasticSearch post series we decided to step away from the technical aspects of SolrCloud vs. ElasticSearch and look at the communities gathered around thesee two projects. If you haven’t read the previous posts about Apache Solr vs. ElasticSearch here are pointers to all of them:</p>

<p>ApacheCon EU 의 제 강연이 끝난 뒤 받은 질문 중하나는 제가 비교한 두가지 검색엔진의 커뮤니티에 대해서 어떻게 생각하느냐 하는 것이었습니다. 당연하게도 이것은 우리가 컨설팅 계약에서 자주 지적하는 문제이기도 합니다. Apache Solr vs ElasticSearch 시리즈의 글로써 우리는 SolrCloud vs ElasticSearch 의 기술적 요소에서 떠나 아직 ElasticSearch 의 과거의 글들을 읽지 않은 경우에는 여기에 모든 포인터가 있습니다.</p>

<ol>
<li>Solr vs. ElasticSearch: Part 1 – Overview</li>
<li>Solr vs. ElasticSearch: Part 2 – Data Handling</li>
<li>Solr vs. ElasticSearch: Part 3 – Searching</li>
<li>Solr vs. ElasticSearch: Part 4 – Faceting</li>
<li>Solr vs. ElasticSearch: Part 5 – Management API Capabilities</li>
<li>Solr vs. ElasticSearch: Part 6 – User &amp; Dev Communities Compared</li>
</ol>

<h2>유저와 커뮤니티</h2>

<p>Let’s start by discussing the user activity around both ElasticSearch and Apache Solr.</p>

<p>ElasticSearch 와 Apache Solr 양쪽의 유저의 활동에 대해서 이야기를 해 볼까요?</p>

<h3>유저 활동</h3>

<p>We started working on this post right before the Christmas break of 2012. During that time we decided to see how active the user base was for both ElasticSearch and Apache Solr. To do that we used our handy search-lucene.com service and we compared the number of email messages sent to both user list. So let’s see how they stack up.</p>

<p>이 글을 2012년 크리스마스 휴가 전에 시작했습니다. 그 사이 ElasticSearch 와 Apache Solr 두 검색엔진의 유저기반이 어느 정도로 활발한지를 알아보았습니다. 이에 대해서 우리는 편리한 search-lucene.com 서비스를 사용해서 두 검색엔진의 메일링리스트로 보내진 이메일 메시지 수를 비교해봤습니다. 우선 그것들이 어떻게 다른지 보도록 하겠습니다.</p>

<h4>Apache Solr</h4>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/solr_user.png" alt=""></p>

<p>As you can see, Solr user activity varies slightly from month to month which is perfectly understandable. Each bar on the chart represents two weeks. We can see the number of messages ranges from about 390 mails to about 770 per two weeks, which gives us between 800 to 1600 mails per month is we do a bit of rounding up. Quite impressive I must say!</p>

<p>보시다시피, Solr 의 유저활동은 매월 확실하게 다르다는 것을 알 수 있습니다. 차트 위의 각 막대는 2주간을 나타냅니다. 메시지 수의 범위는 2주일마다 약 390통에서 770통이며, 매월 800에서 1600통이 된다고 합시다. 매우 인상적이라고 할 수 있겠죠.</p>

<h4>ElasticSearch</h4>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/es_user.png" alt="ElasticSearch User Mailing List"></p>

<p>Now let’s discuss the ElasticSearch side. First a few words of explanation. If you look at the above chart you might think that ElasticSearch mailing list was silent and then users started posting on October 2012. That’s clearly not true – it is just that we didn’t add ElasticSearch to search-lucene.com until recently.  However, you may see that the number of messages during the same period of time is quite similar – both Solr and ElasticSearch saw about 670 – 730 messages during a two weeks period. This gives us 2 emails per hour on average.</p>

<p>ElasitcSearch 를 볼까요? 먼저 잠깐 설명을 하자면, 위의 차트를 보면 ElasticSearch 의 메일링리스트는 조용하고 유저는 2012년 10월에 투고를 시작했구나 하고 생각할 수 있겠지만, 그렇지 않습니다. 이건 단지 우리들이 ElasticSearch 에 대해 최근까지 search-lucene.com 에 추가하지 않았기 때문이죠. 하지만 같은 기간의 메시지 수는 매우 비슷하다는 것을 알 수 있습니다. Solr 와 ElasticSearch 는 2주간 약 670에서 730통 정도로 볼 수 있습니다. 이것은 평균 1시간당 2통 정도가 되겠네요.</p>

<h3>개별 유저의 수</h3>

<p>Email volume is one thing, but I was always curious about how many different people write emails on the mailing lists. Having such number would give us an additional understanding of the structure of the community around a particular search engine, new users, etc. However, we should not look only at this number, but also on things like most active people on the mailing lists. In both cases we’ve looked at the same period from 1 to 30 December 2012. We’ve used the data we index for search-lucene.com to calculate these numbers.</p>

<p>이메일 수는 하나의 지표입니다. 하지만 우리는 항상 어느정도의 다른 사람이 메일링리스트에 써왔는지를 주목했습니다. 그런 숫자를 통해서 검색 엔진이나 새로운 유저에 관한 커뮤니티의 구조에 대해서 보다 깊은 이해를 얻을 수 있습니다. 하지만 이 숫자뿐만 아니라, 가장 활발한 메일링 리스트 상의 사람들도 참고해보도록 합니다. 양쪽의 케이스에 대해서 2012년 12월 1일부터 30일까지의 같은 기간을 두고 조사했습니다. 사용한 데이터는 우리가 search-lucene.com 에서 이 숫자들을 계산하기 위해 인덱싱한 것입니다.</p>

<h4>Apache Solr</h4>

<p>In case of Apache Solr there were 234 unique users sending mail to the users mailing list. Almost 8 unique users per day on average, nice :)</p>

<p>Apache Solr 에서는 234명의 사람들이 유저 메일링리스트에 메일을 보내왔습니다. 하루 평균 약 8명의 유저입니다. 굉장하네요.</p>

<h4>ElasticSearch</h4>

<p>In case of ElasticSearch there were 271 unique users sending mail to the users mailing list. This gives us about 9 unique users per day on average which is even nicer.</p>

<p>ElasticSearch 는 271명의 유저가 메일링리스트에 메일을 보냈습니다. 하루 평균 약 9명인데, 더 굉장하네요.</p>

<h2>사용가능한 리소스</h2>

<p>As far as resources available, both ElasticSearch and Solr have great documentation. On Solr wiki site (<a href="http://wiki.apache.org/solr/">http://wiki.apache.org/solr/</a>) you can find information about most of the components and of course the tutorial for beginners. ElasticSearch is very similar, with tutorial and very good description of functionality available at <a href="http://www.elasticsearch.org/">http://www.elasticsearch.org/</a>. In addition to that, there are three books published about Apache Solr (in English) and more (e.g. my Apache Solr 4 Cookbook) coming soon. As of now, there are no published books about ElasticSearch, but…. stay tuned :)</p>

<p>사용가능한 리소스에 관해서, ElasticSearch 와 Solr 양쪽 모두 매우 좋은 문서를 가지고 있습니다. Solr Wiki Site(<a href="http://wiki.apache.org/solr/">http://wiki.apache.org/solr/</a>) 에서는 대부분의 컴포넌트는 물론 초보자용 튜토리얼에 관한 정보도 얻을 수 있습니다. ElasticSearch 도 마찬가지로 튜토리얼과 매우 좋은 기능설명이 <a href="http://www.elasticsearch.org/">http://www.elasticsearch.org/</a> 에 있습니다. 그리고 Apache Solr 에는 (영어로 된) 책이 3권 출판되었고, 거기에 (예를들어 저의 Apache Solr 4 Cookbook)이 곧 나올 예정입니다. 지금까지는 ElasticSearch 에 관한 책은 아직 출판되지 않았지만&hellip; 좀 더 기다려 볼까요 :)</p>

<h2>검색 상의 트렌드</h2>

<p>We also decided to use uncle Google to look at trends about Apache Solr and ElasticSearch. Let’s look at the following diagram:</p>

<p>Googleおじさんを使用してApache SolrとElasticSearchのトレンドを調べてみよう。次の図を見て欲しい。</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/solr-vs-es-google-trends.png" alt=""></p>

<p>As you can see, until early 2010 there was no interest in ElasticSearch at all, at least looking from the point of view of users searching about it. Note that we published the interview with Shay Banon over two and a half years ago – back in May 2010 – before ElasticSearch registered on Google’s search trends radar! SolrCloud didn’t exist back then, so people slowly started looking for information on SolrCloud later in 2010.  The volume of searches mentioning SolrCloud is very small even today – perhaps because people tend to search for Solr and not SolrCloud.  And while SolrCloud is still a new kid around the block, searches for Solr dwarf searches for ElasticSearch despite the buzz surrounding ElasticSearch.</p>

<p>보시다시피 2012년초까지는 ElasticSearch 에 대한 흥미는 전혀 없었습니다. 적어도 그것을 검색한 사람의 수로 보면 그렇죠. 참고해둘 것은 우리가 Shay Banon 과 인터뷰를 공개한 것은 2년반 전이라는 것입니다. 즉 2010년 5월. ElasticSearch 가 Google 검색트렌드의 트레이드레이더에 등록되기도 전이죠. SolrCloud 는 그 당시에 존재하지도 않았습니다. 따라서 사람들은 느긋하게 SolrCloud 에 관한 정보를 2010년 말에 찾기 시작했습니다. 검색량이 나타내는 것은 SolrCloud 는 지금도 매우 적습니다. 아마 많은 사람들이 Solr 로 검색하지, SolrCloud 로는 하지 않기 때문이겠죠. 그리고 SolrCloud 가 지금도 갓 나온 것과 달리, Solr 에 대한 검색은 ElasticSearch 에 대한 검색보다 조금 더 눈에 뜁니다. ElasticSearch 에 대한 Buzz 에도 불구하고 말이죠.</p>

<p>Of course, the above doesn’t say anything about the number of users of both search engines, but it definitely shows some information about the interest in these technologies.</p>

<p>물론 위에서 두 검색엔진의 유저 수에 대해서는 말할 것도 없습니다. 하지만 두 기술에 대한 흥미를 나타내는 어떤 정보라는 것은 결정적이죠.</p>

<h2>개발자와 코드</h2>

<p>If you are familiar with ElasticSearch and Solr you’ll probably know that ElasticSearch is much younger than Apache Solr. Apache Solr was created by Yonik Seeley in 2004 and donated to Apache Software Foundation. On the other hand, the first version of ElasticSearch was released by Shay Banon in 2010. This is quite important to say before we can talk about differences about contributors and the code itself. But getting to the point – we thought that it may be interesting to see both Apache Solr and ElasticSearch look from the Bird’s Eye perspective. To do that we’ve used the statistics and charts from ohloh.net. So, let’s see what they look like.</p>

<p>만약 ElasticSearch 와 Solr 에 익숙하다면 아마도 ElasticSearch 쪽이 Apache Solr 와 비교해서 조금 더 어리다는 것을 알고 있을 겁니다. Apache Solr 와 Yonik Seeley 에 의해 2004년에 만들어져 Apache 소프트웨어 재단에 기증되었습니다. 반면 ElasticSearch 의 최초 버젼은 2010년 Shay Banon 에 의해서 릴리즈 되었죠. 이것은 공헌자와 코드 자체의 차이에 대해서 의논하기 전에 매우 중요한 것입니다. 하지만 그전에 Apache Solr 와 ElasticSearch 를 관망적으로 보는 것도 좋다고 생각합니다. 그러기 위해서 ohloh.net 에서 통계와 그래프를 사용했습니다. 그럼 한번 볼까요?</p>

<h3>Apache Solr</h3>

<h4>코드 통계</h4>

<p>If we look at the current statistics, at the beginning of January 2013 Solr had more than 212k lines of code, with almost 7000 commits and 38 contributors. However, keep in mind that contributors are people that committed the code, not necessarily the ones that actually implemented it and provided the patch, so the actual number of contributors is much higher. The chart looks like this: !</p>

<p>현재의 통계를 보면 2012년 1월 처음으로 Solr 는 212k줄 이상의 코드를 가지고, 약 7000커밋과 38명의 컨트리뷰터가 있습니다. 하지만 주의할 것은 컨트리뷰터라는 것은 코드를 커밋한 사람들을 나타내며, 실제로 구현해서 패치를 제공한 사람들이 아니라는 것입니다. 그 때문에 실제 컨트리뷰터 수는 보다 많을 것이라고 장담합니다. 아래의 그래프를 볼까요.</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/lines_of_code_solr1.png" alt="lines_of_code_solr"></p>

<h4>최고의 컨트리뷰터</h4>

<p>If we look at top contributors we see Mark Miller on top, followed by Yonik Seeley and Robert Muir in the third place :)</p>

<p>최고의 컨트리뷰터는 Mark Miller 입니다. 이어서 Yonik Seeley, 그리고 Robert Muir 가 3위를 잇고 있습니다. :)
<img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/top_commiters_solr.png" alt="Active Contributors"></p>

<h4>활동적인 컨트리뷰터</h4>

<p>One more interesting thing is the number of contributors that were actively involved during a given period of time. Looking at Apache Solr since 2006 we can see the following: active_commiters_solr I think that we can say that we had a stable growth of active contributors starting from 2006 until June 2012 with a bit of downfall shortly after that. However I don’t think that the number active contributors will be dropping, it’s more likely due to a bit of exhaustion of releasing Apache Lucene and Solr 4.0 :)</p>

<p>또 하나 재미있는 것은 어떤 기간 사이에 실제로 관계한 컨트리뷰터 수입니다. Apache Solr 에 관해서는 2006년부도 보면 다음과 가튼 사실을 알 수 있습니다:
제가 생각하기에 2006년부터 2012년 6월까지 안정적이고 활동적인 컨트리뷰터의 증가가 있었다고 장담합니다. 그 뒤에 다소 하락폭이지만요. 하지만 활동적인 컨트리뷰터의 수가 이후 줄어들고 있다고 생각하지 않습니다. 오히려 Apache Lucene 과 Solr 의 4.0 릴리즈로 맥이 빠져 있겠죠. :)</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/active_commiters_solr.png" alt=""></p>

<h3>ElasticSearch</h3>

<h4>코드 통계</h4>

<p>Current code statistics for ElasticSeach shows that the code base just hit the 240k LOC  with about 4.2k commits and 87 contributors. lines_of_code_es</p>

<p>현재 ElasticSearch의 코드 통계는 코드베이스가 240k줄이고 4.2k 의 커밋과 87명의 컨트리뷰터입니다.</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/lines_of_code_es.png" alt=""></p>

<h4>최고의 공헌자</h4>

<p>As we’d expect, Shay Banon is the top contributor to ElasticSearch. In the second place on the podium we have Martijn van Groningen and Igor Motov in the third place: </p>

<p>기대한대로 Shay Banon 이 ElasticSearch의 최고 공헌자입니다. 2위는 Martijn van Groningen 이고 3위는 Igor Motov 입니다.</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/top_commiters_es.png" alt=""></p>

<h5>활동적인 컨트리뷰터</h5>

<p>And finally the active contributors. We don’t have the same time frame comparing to Apache Solr, which is understandable as ElasticSearch is younger, but still we can see what is happening. active_commiters_es As you can see from the first quarter of 2011 there was a number of active contributors varying from 5 to about 10 with the top at the same time as in Solr – 12 active contributors in June 2012.</p>

<p>마지막으로 활동적인 컨트리뷰터입니다. Apache Solr 와는 달리 같은 수준의 타임프레임으로는 비교할 수 없습니다. ElasticSearch 가 훨씬 어리기 때문이죠. 하지만 그래도 무슨 일이 있는 지는 봐야되겠죠.</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/active_commiters_es.png" alt=""></p>

<p>2011 년 1/4분기에서 볼 수 있듯, 활동적인 컨트리뷰터의 수는 5에서 10명까지 바뀌고 있고, Solr 와 같은 시기인 7월에 최대 12명을 기록하고 있습니다.</p>

<h2>정리</h2>

<p>As everything in this post indicates, both projects’ development and user communities are strong, active, and about equal. 2013 will be an interesting year for both projects.</p>

<p>이 글이 나타내는 대로, 두 프로젝트의 개발자와 유저 커뮤니티는 강력하고 활동적이며 그리고 대체로 비슷합니다. 2013년은 두 검색엔진에 있어서 재미있는 한 해가 되겠죠.</p>

<p>We are nearing the end of our SolrCloud vs. ElasticSearch series.  What else would you like us to cover?  Please use the comments to let us know!</p>

<p>SolrCloud vs ElasticSearch 시리즈도 이제 끝입니다. 혹시 뭔가 다른 것을 다뤘으면 하는 게 있나요? 커멘트로 알려주세요.</p>

<ul>
<li>@kucrafal, @sematext</li>
</ul>
</div>

  <footer>
    
    <p><a class="comments-link" href="/2013/07/17/solr-vs-elasticsearch-part-6-user-and-dev-communities-compared/#disqus_thread" data-disqus-identifier="http://jeen.github.io/2013/07/17/solr-vs-elasticsearch-part-6-user-and-dev-communities-compared/">View comments &raquo;</a></p>

    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/2013/07/17/solr-vs-elasticsearch-part-5-management-api-capabilities/">Solr vs ElasticSearch: Part 5 – Management API Capabilities</a>

</h1>

    
      <p class="meta">
        








  



<time datetime="2013-07-17T00:01:06+00:00" pubdate data-updated="true">Jul 17<span>th</span>, 2013</time>
         &bull; <a rel="bookmark" href="/2013/07/17/solr-vs-elasticsearch-part-5-management-api-capabilities/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><h1>Solr vs ElasticSearch: Part 5 – Management API Capabilities</h1>

<p>January 8, 2013 by Rafał Kuć</p>

<p>In previous posts, all listed below, we’ve discussed general architecture, full text search capabilities and facet aggregations possibilities. However, till now we have not discussed any of the administration and management options and things you can do on a live cluster without any restart. So let’s get into it and see what Apache Solr and ElasticSearch have to offer.</p>

<p>이전 편에서는 전반적인 개요, 전문검색기능, Faceting 의 집약기능에 대해서 다루었습니다. 지금까지 관리와 운영 옵션과 운용중의 클러스터에서 재기동없이 할 수 있는 일에 대해서는 다루지 않았죠. 자, 그럼 이에 대해서 Apache Solr 와 ElasticSearch 는 무엇을 제공할 수 있는 지 보도록 할까요?</p>

<ol>
<li>Solr vs. ElasticSearch: Part 1 – Overview</li>
<li>Solr vs. ElasticSearch: Part 2 – Data Handling</li>
<li>Solr vs. ElasticSearch: Part 3 – Searching</li>
<li>Solr vs. ElasticSearch: Part 4 – Faceting</li>
<li>Solr vs. ElasticSearch: Part 5 – Management API Capabilities</li>
<li>Solr vs. ElasticSearch: Part 6 – User &amp; Dev Communities Compared</li>
</ol>

<h2>Input/Output Format</h2>

<h3>ElasticSearch</h3>

<p>As you probably know ElasticSearch offers a single way to talk to it – its HTTP REST API – JSON structured queries and responses. In most cases, especially during query time, it is very handy, because it let’s you perfectly control the structure of your queries and thus control the logic.</p>

<p>알고 계시겠지만 ElasticSearch 는 하나의 통신방법을 제공합니다. 그것이 바로 HTTP REST API이며 이는 JSON 구조로 쿼리와 응답을 만들어냅니다. 대부분의 경우, 특히 쿼리시에 매우 편리합니다. 쿼리 구조를 완전하게 컨트롤할 수 있고, 그러므로 로직을 컨트롤할 수 있기 때문입니다.</p>

<h3>Apache Solr</h3>

<p>On the other hand we have Apache Solr. If you are familiar with it you know that in order to send a query to Solr one needs to send it using URL request parameters.  This makes communication much less structured compared to ElasticSearch JSON format. In response you can get multiple response formats that are supported out of the box, like the default XML, JSON, CSV, PHP serialized, or Ruby.</p>

<p>반면 Apache Solr 는 쿼리를 보낼 때에 URL 리퀘스트 파라메터를 보낼 필요가 있다는 것은 알고 계실겁니다. 이것이 ElasticSearch 의 JSON 형식과 비교하면 커뮤니케이션을 보다 낮은 수준으로 구조화해버리는 것이죠. 하지만 응답시에는 여러 응답형식을 지원하고 있습니다. 기본적으로 XML, JSON, CSV, 직렬화된 PHP, Ruby 가 그것들이죠.</p>

<h2>Statistics API</h2>

<p>Most of the time your search cluster will be fine and you won’t have any problems with it. However, there are times where you may need to see what is happening inside Apache Solr or ElasticSearch to diagnose problems, such as performance problems (hello SPM!), stability issues, or anything like that. In such cases, both search engines provide some amount of statistics.</p>

<p>대부분의 경우, 검색 클러스터는 튼튼하고 문제를 일으키는 일은 없을 것 입니다. 그러나 Apache Solr 나 ElasticSearch 에서 무슨 일이 일어났는가를 보고 문제 진단을 해 볼 필요가 있습니다. 예를들어서 퍼포먼스 문제나(어이, SPM!) 안전성의 문제 와 같은 것들이죠. 그런 경우에는 두 검색엔진은 몇가지의 통계값을 제공합니다.</p>

<h3>Apache Solr</h3>

<p>In Solr we can use JMX or HTTP requests to retrieve information about handler usage, cache statistics or information about most Solr components.</p>

<p>Solr 에서는 JMX 나 HTTP 질의를 핸들러로 캐쉬의 통계, 그리고 대부분의 Solr 컴포넌트의 정보를 얻을 때에 이용할 수 있습니다.</p>

<h3>ElasticSearch</h3>

<p>ElasticSearch was designed to be able to return various statistics about itself. With the REST API calls we can get information from the simplest ones like cluster health or nodes statistic, to extent information like the detailed ones about indices with merges, refreshes. The same stats are available via JMX, too.</p>

<p>ElasticSearch는 자체적으로 다양한 통계를 반환할 수 있도록 설계되었습니다. REST API 의 호출을 사용해서 가장 단순한 것, 예를 들자면 클러스터의 건강상태나 노드의 통계에서 인덱스의 머지, 리프레쉬와 같은 상세한 것 등의 광범위한 정보를 얻을 수 있습니다. 이와 같은 정보는 JMX 경유로 얻을 수 있습니다.</p>

<h2>Settings API</h2>

<h3>ElasticSearch</h3>

<p>ElasticSearch allows us to modify most of the configuration values dynamically. For example, you can clear you caches (or just specific type of cache), you can move shards and replicas to specific nodes in your cluster. In addition to that you are also allowed to update mappings (to some extent), define warming queries (since version 0.20), etc. You can even shut down a single node or a whole cluster with the use of a single HTTP call. Of course, this is just an example and doesn’t cover all the possibilities exposed by ElasticSearch.</p>

<p>ElasticSearch는 동적으로 설정값의 대부분을 변경할 수 있습니다. 예를 들어 캐쉬를 클리어했다든가, 특정 타입의 캐쉬만을 클리어했다거나, Shard 와 레플리카를 클러스터로 지정한 노드로 이동할 수 있습니다. 그리고 어떤 범위의 맵핑을 변경하거나 워밍쿼리(v0.20이후)를 정의할 수도 있습니다. 단일 노드나 클러스터 전체를 한번의 HTTP 호출로 셧다운할 수도 있죠. 물론 이것들은 단순히 일부분 일 뿐이며, ElasticSearch 에서 공개된 기능 전체를 커버하는 것은 아닙니다.</p>

<h3>Apache Solr</h3>

<p>In case of Apache Solr we do not (yet) have the possibility of changing configuration values (like warming queries) with API calls.</p>

<p>Apache Solr 의 경우, API 호출로 설정값의 변경 (예를들어 워밍쿼리)할 수 있는 기능은 &ldquo;아직&rdquo; 없습니다.</p>

<h2>인덱스/콜렉션의 관리기능</h2>

<p>In addition to the capabilities mentioned above both ElasticSearch and Apache Solr provide APIs that allows us to modify our deployment when it comes to collections and indices.</p>

<p>위에서 설명한 기능 이외에 ElasticSearch 와 Apache Solr 는 콜렉션과 인덱스에 관한 디플로이를 변경할 수 있습니다.</p>

<h3>Apache Solr</h3>

<p>Pre 4.0 we were able to manipulate cores inside our Solr instances. We could create new cores, reload them, get their status, rename, swap two of them, and finally remove a core from the instance. With Solr 4.0, a new API was introduced that is built on top of core admin API – the collections API. It allows us to create collections on started SolrCloud cluster, reload them and of course delete them. As the collections API is built on top of the core admin API,  if you create a new collection all the needed cores on all instances will be created. Of course, the same goes for reloading and deleting – all the cores will be appropriately informed and processed.</p>

<p>4.0 이전에는 Solr 인스턴ㅅ 안에 여러 코어를 만질 수 있었습니다. 새로운 코어를 만들거나 리로드 하거나, 상태정보를 얻거나, 이름을 바꾸거나, 두가지를 스와핑하거나, 마지막으로 인스턴스에서 코어를 삭제할 수 가 있었습니다. Solr 4.0 에서는 코어관리 API 의 맨 위에 새로운 API 가 새로이 소개되었습니다. 그것이 바로 Collections API 입니다. 이미 시작한 SolrCloud 클러스터 위에 콜렉션을 만들거나 리로드, 삭제도 할 수 있습니다. 콜렉션 API 가 코어 관리 API 위에서 구축되어 새로운 콜렉션을 만들면 모든 인스턴스 상의 필요한 코어가 모두 작성됩니다. 마찬가지로 리로드나 삭제도 가능합니다. 모든 코어는 적절하게 정보를 받아 처리됩니다.</p>

<h3>ElasticSearch</h3>

<p>In case of ElasticSearch we can create and delete indices by running a simple HTTP command (GET or DELETE method) with the index name we are interested in. In addition to that, with a simple API call we can increase and decrease the number of replicas without the need of shutting down nodes or creating new nodes. With the newer ElasticSearch versions we can even manipulate shard placement with the cluster reroute API. With the use of that API we can move shards between nodes, we can cancel shard allocation process and we can also force shard allocation – everything on a live cluster.</p>

<p>ElasticSearch 의 경우, 간단한 HTTP 커맨드(GET 또는 DELETE 메소드)를 대상으로 한 인덱스의 이름과 함께 실행하는 것만으로 인덱싱과 삭제가 가능합니다. 그리고 간단한 API 호출로 레플리카의 수를 노드의 셧다운이나 추가없이 증감할 수도 있습니다. 새로운 ElasticSearch 버젼에서는 Shard 의 배치를 클러스터의 리로드 API 로 할 수 있습니다. 이를 통해서 Shard 를 노드끼리 이동한다거나, Shard 를 할당절차를 취소하거나 강제할 수도 있습니다. 모든 것은 운용중의 클러스터 위에서 가능합니다.</p>

<h2>Query Analysis</h2>

<h3>Apache Solr</h3>

<p>If you’ve used Apache Solr you probably come across the debugQuery parameter and the explainOther parameter. Those two allows to see the detailed score calculation for the given query and documents found in the results (the debugQuery parameter) and the specified ones (the explainOther). In addition, we can also see how the analysis process is done with the use of analysis handler or by using the analysis page of the Solr administration panel provided with Solr.</p>

<p>Apache Solr 를 이전에 사용한 적이 있다면 debugQuery 파라메터와 explainOther 파라메터를 알고 있으실 겁니다. 이 두가지를 사용해서 주어진 쿼리와 그 결과를 발견한 도큐먼트(debugQuery파라메터), 또는 특정 하나의(plainOther)의 스코어 계산에 대한 자세한 내용을 볼 수도 있습니다. 거기에 해석핸들러를 사용하거나 Solr 에서 제공되는 Solr 관리패널의 해석페이지로 해석프로세스가 어떻게 이뤄지는 지도 확인할 수 있습니다.</p>

<p>For example this is how debug information returned by Solr can look like:</p>

<p>Solr로 반환되는 디버그 정보가 어떻게 보여지는 가는 아래를 참고해주세요.</p>
<div class="highlight"><pre><code class="text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;response&gt;
.
.
.
&lt;lst name=&quot;debug&quot;&gt;
 &lt;str name=&quot;rawquerystring&quot;&gt;ten&lt;/str&gt;
 &lt;str name=&quot;querystring&quot;&gt;ten&lt;/str&gt;
 &lt;str name=&quot;parsedquery&quot;&gt;(+DisjunctionMaxQuery((prefixTok:ten)~0.01) ())/no_coord&lt;/str&gt;
 &lt;str name=&quot;parsedquery_toString&quot;&gt;+(prefixTok:ten)~0.01 ()&lt;/str&gt;
 &lt;str name=&quot;QParser&quot;&gt;DisMaxQParser&lt;/str&gt;
 &lt;null name=&quot;altquerystring&quot;/&gt;
 &lt;null name=&quot;boostfuncs&quot;/&gt;
 &lt;lst name=&quot;timing&quot;&gt;
  &lt;double name=&quot;time&quot;&gt;2.0&lt;/double&gt;
  &lt;lst name=&quot;prepare&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;1.0&lt;/double&gt;
   &lt;lst name=&quot;org.apache.solr.handler.component.QueryComponent&quot;&gt;
    &lt;double name=&quot;time&quot;&gt;1.0&lt;/double&gt;
   &lt;/lst&gt;
   &lt;lst name=&quot;org.apache.solr.handler.component.FacetComponent&quot;&gt;
    &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
   &lt;/lst&gt;
   &lt;lst name=&quot;org.apache.solr.handler.component.MoreLikeThisComponent&quot;&gt;
    &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
   &lt;/lst&gt;
   &lt;lst name=&quot;org.apache.solr.handler.component.HighlightComponent&quot;&gt;
    &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
   &lt;/lst&gt;
   &lt;lst name=&quot;org.apache.solr.handler.component.StatsComponent&quot;&gt;
    &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
   &lt;/lst&gt;
   &lt;lst name=&quot;org.apache.solr.handler.component.DebugComponent&quot;&gt;
    &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
   &lt;/lst&gt;
 &lt;/lst&gt;
 &lt;lst name=&quot;process&quot;&gt;
  &lt;double name=&quot;time&quot;&gt;1.0&lt;/double&gt;
  &lt;lst name=&quot;org.apache.solr.handler.component.QueryComponent&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
  &lt;/lst&gt;
  &lt;lst name=&quot;org.apache.solr.handler.component.FacetComponent&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
  &lt;/lst&gt;
  &lt;lst name=&quot;org.apache.solr.handler.component.MoreLikeThisComponent&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
  &lt;/lst&gt;
  &lt;lst name=&quot;org.apache.solr.handler.component.HighlightComponent&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
  &lt;/lst&gt;
  &lt;lst name=&quot;org.apache.solr.handler.component.StatsComponent&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;0.0&lt;/double&gt;
  &lt;/lst&gt;
  &lt;lst name=&quot;org.apache.solr.handler.component.DebugComponent&quot;&gt;
   &lt;double name=&quot;time&quot;&gt;1.0&lt;/double&gt;
  &lt;/lst&gt;
 &lt;/lst&gt;
&lt;/lst&gt;
&lt;lst name=&quot;explain&quot;&gt;
 &lt;str name=&quot;Ten mices&quot;&gt;
1.3527006 = (MATCH) sum of:
 1.3527006 = (MATCH) weight(prefixTok:ten in 35158) [DefaultSimilarity], result of:
 1.3527006 = fieldWeight in 35158, product of:
 1.4142135 = tf(freq=2.0), with freq of:
 2.0 = termFreq=2.0
 6.1216245 = idf(docFreq=6355, maxDocs=1065313)
 0.15625 = fieldNorm(doc=35158)
 &lt;/str&gt;
&lt;/lst&gt;
&lt;/lst&gt;
&lt;/response&gt;
</code></pre></div>
<p>As you can see, we can get information about timings of each of the used components. In addition to that, we see the parsed query and of course the explain information showing us how the document score was calculated.</p>

<p>보시는 대로, 사용하고 있는 각 컴포넌트의 타이밍에 관한 정보를 얻을 수 있습니다. 그리고 파싱된 쿼리를 보거나, 어떻게 도큐먼트의 스코어가 계산되는 가를 알 수 있는 explain 정보도 확인가능합니다.</p>

<h3>ElasticSearch</h3>

<p>ElasticSearch exposes three separate REST end-points to analyze our queries, documents and explain the documents score. The Analyze API allows us to test our analyzer on a specified text in order to see how it is processed and is similar to the analysis page functionality of Solr. The Explain API provides us with information about the score calculation for a given documents. Finally, the Validate API can validate our query to see is it is proper and how expensive it can be.</p>

<p>ElasticSearch는 3개로 나뉘어진 REST 엔드포인트를 공개하여, 쿼리나 도큐먼트, 도큐먼트 스코어의 explain 을 해석할 수 있습니다. 해석API 는 해석기가 특정 텍스트에서 어떻게 처리되는지를 테스트할 수 있습니다. SOlr 의 해석페이지 기능과 비슷합니다. Explain API 는 주어진 도큐먼트에 대해서 스코어 연산에 관한 정보를 제공합니다. 마지막으로 Validate API 는 쿼리가 적절하게 어느 정도의 비용인지를 확인할 수 있습니다.</p>

<p>For example, this is what Explain API response looks like:</p>

<p>Explain API 의 응답은 아래와 같습니다.</p>
<div class="highlight"><pre><code class="text">{
 &quot;ok&quot; : true,
 &quot;_index&quot; : &quot;docs&quot;,
 &quot;_type&quot; : &quot;doc&quot;,
 &quot;_id&quot; : &quot;1&quot;,
 &quot;matched&quot; : true,
 &quot;explanation&quot; : {
   &quot;value&quot; : 0.15342641,
   &quot;description&quot; : &quot;fieldWeight(_all:document in 0), product of:&quot;,
   &quot;details&quot; : [ {
     &quot;value&quot; : 1.0,
     &quot;description&quot; : &quot;tf(termFreq(_all:document)=1)&quot;
   }, {
     &quot;value&quot; : 0.30685282,
     &quot;description&quot; : &quot;idf(docFreq=1, maxDocs=1)&quot;
   }, {
     &quot;value&quot; : 0.5,
     &quot;description&quot; : &quot;fieldNorm(field=_all, doc=0)&quot;
   } ]
 }
}
</code></pre></div>
<p>You can see the description about score calculation that is returned from the Explain API.</p>

<p>Explain API로 반환되는 스코어 계산에 대한 내용을 알 수 있겠죠?</p>

<h2>Before We End</h2>

<p>There are a few words more we wanted to write before summarizing this comparison. First of all the above mentioned APIs and possibilities are not all that it is available, especially when it comes to ElasticSearch. For example, with ElasticSearch you can clear caches on the index level, you can check index and types existence, you can retrieve and manage your warming queries, clear the transaction log by running the Flush API, or  even close an index or open those that were closed. We wanted to point some differences and similarities between Apache Solr and ElasticSearch, but we didn’t want to make a summary of the documentation. :) So, if you are interested in some functionality and you don’t know if it exists, just send a mail to Apache Solr or ElasticSearch mailing list or leave a comment here, and we will be glad to help.</p>

<p>이 비교를 정리하기 전에 좀 더 써두고 싶은 것이 있습니다. 우선 맨처음 위에서 설명한 API 와 기능은 두 검색엔진이 가진 모든 기능이 아닙니다. 특히 ElasticSearch가 그렇습니다. 예를들어 ElasticSearch 에서는 인덱스 레벨 위에서 캐쉬를 지우거나 존재하는 인덱스와 타입을 확인하거나, 워밍쿼리를 뽑고, 관리하거나, 플러쉬 API 를 시행해서 트랜잭션로그를 삭제하거나, 거기에 인덱스를 닥거나 닫힌 인덱스를 여는 것도 가능합니다. 우리는 Apache Solr 와 ElasticSearch 의 차이와 유사점에 대해서 다루고 싶었지, 정리한 문서를 만들고 싶지는 않았습니다. :) 따라서 만약 어떤 기능에 흥미가 있고, 그런 기능이 있는 지 모르는 경우는 Apache Solr 나 ElasticSearch 의 메일링리스트에 메일을 보내거나 여기에 코멘트를 남겨주세요. 기꺼이 도와드리겠습니다.</p>

<h2>정리</h2>

<p>When we first started the Solr vs ElasticSearch series we planned to initially divide the series into five posts, which are now published. However after seeing the popularity of the series and the amount of feedback we’ve received, we decided to extend the series. You can soon expect the next part, which will be dedicated to non-technical, but deeply important and interesting aspects of both search servers. After that, we’ll get back to the technical details with the subsequent post  dedicated to score influence capabilities, describing how we can change the default Lucene scoring and influence it from configuration, during indexing time and finally during querying.</p>

<p>Solr vs ElasticSearch 시리즈를 시작했을 때, 우리는 시리즈를 다섯개의 기사로 나눌 예정이었습니다. 하지만 이 시리즈의 인기와 여러 피드백의 양을 생각한 결과 이 시리즈를 확장하기로 했습니다. 이미 다음편을 기대하고 있겠죠. 다음편은 비기술적이지만 매우 중요하고 재미있는 두 가지 검색서버의 측면에 대해서 다루고자 합니다. 그리고 기술적인 자세한 이야기에 이은 포스트에서는 반환되는 스코어에 영향을 주는 기능에 대해서 다루고, 인덱싱할 때와 최종적으로 쿼리 사이에 어떻게 Lucene 의 기본 스코어링을 바꿔서 설정에서 영향을 줄 수 있는 가를 다루고자 합니다.</p>

<p>If you liked this post, please tweet it!</p>

<p>이 글이 좋아한다면 트윗해주세요.</p>

<ul>
<li>@kucrafal, @sematext</li>
</ul>
</div>

  <footer>
    
    <p><a class="comments-link" href="/2013/07/17/solr-vs-elasticsearch-part-5-management-api-capabilities/#disqus_thread" data-disqus-identifier="http://jeen.github.io/2013/07/17/solr-vs-elasticsearch-part-5-management-api-capabilities/">View comments &raquo;</a></p>

    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/2013/07/16/solr-vs-elasticsearch-part-4-faceting/">[번역] Solr vs ElasticSearch Part 4 - Faceting</a>

</h1>

    
      <p class="meta">
        








  



<time datetime="2013-07-16T16:06:42+00:00" pubdate data-updated="true">Jul 16<span>th</span>, 2013</time>
         &bull; <a rel="bookmark" href="/2013/07/16/solr-vs-elasticsearch-part-4-faceting/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><h1>Solr vs ElasticSearch: Part 4 – Faceting</h1>

<p>October 30, 2012 by Rafał Kuć</p>

<p>Solr 4 (aka SolrCloud) has just been released, so it’s the perfect time to continue our ElasticSearch vs. Solr series. In the last three parts of the ElasticSearch vs. Solr series we gave a general overview of the two search engines, about data handling, and about their full text search capabilities. In this part we  look at how these two engines handle faceting.</p>

<p>Solr 4 (또는 SolrCloud) 가 릴리즈되었습니다. ElasticSearch vs. Solr 시리즈를 계속하기에는 완벽한 시기라고 말할 수 있겠죠. ElasticSearch vs. Solr 시리즈의 이전 3편에서는 두가지 검색 엔진 전체의 개요, 데이터 취급, 전문검색능력에 대해서 이야기했습니다. 이번 파트에서는 두 엔진이 어떻게 Faceting 을 다루는지를 알아봅니다.</p>

<ol>
<li>Solr vs. ElasticSearch: Part 1 – Overview</li>
<li>Solr vs. ElasticSearch: Part 2 - Indexing and Language Handling</li>
<li>Solr vs. ElasticSearch: Part 3 – Searching</li>
<li>Solr vs. ElasticSearch: Part 4 – Faceting</li>
<li>Solr vs. ElasticSearch: Part 5 - Management API Capabilities</li>
<li>Solr vs. ElasticSearch: Part 6 – User &amp; Dev Communities Compared</li>
</ol>

<h2>Faceting</h2>

<p>When it comes to faceting, both Solr and ElasticSearch have some faceting methods that other search engine does not.  Both search engines allow you to calculate facets for a given field, numerical range, or date range. The key differences are in the details, of course – in the control of how exactly the facets are calculated, in the memory footprint, and whether we can change the calculation method. In most cases ElasticSearch allows more control over faceting, however Solr has some serious advantages, too.  Lets get into details of each of the methods.</p>

<p>faceting 에 대해서는 Solr 와 ElasticSearch 양쪽이 다른 검색엔진이 가지지 않은 몇가지 faceting 메소드를 가집니다. 두 검색엔진 모두가 주어진 필드, 수치범위, 날짜범위의 Faceting 을 계산할 수 있습니다. 주요한 차이는 실제로 Faceting 을 어떻게 계산할 것인가하는 컨트롤, 메모리풋프린트, 그리고 계산방법을 변경할 수 있는가 입니다. 대부분의 경우 ElasticSearch 는 faceting 에 있어서 다채로운 조작이 가능합니다. 그러나 Solr 도 몇가지 중요한 우위점을 가지고 있습니다. 각각의 메소드의 자세한 내용에 들어가 보겠습니다.</p>

<h2>Term Faceting</h2>

<p>This method of faceting allows one to get information about the number of term occurrences in a certain field.</p>

<p>이 faceting 메소드를 통해 어떤 필드안에 어떤 용어가 몇개인가 하는 정보를 얻을 수 있습니다.</p>

<h3>Solr</h3>

<p>Solr let’s you control how many facets are returned, how they are sorted, the minimum quantity required, and so on. In addition to that, in Solr field faceting, you can choose between a couple of different methods for computing facets.  One of these method should be used for fields with a high number of distinct terms, while the second method is best used in the opposite scenario – when you expect relatively few distinct terms in a field being faceted on.</p>

<p>Solr 는 Facet 이 몇개 반환되는가, 그것들이 어떻게 저장되는 가, 최소필요수등을 컨트롤할 수 있습니다. 그리고 Solr 의 필드 faceting 에서는 Facet 계산법을 두세가지의 다른 방법 중에서 선택할 수 있습니다. 이런 메소드 중 하나가 가장 수가 많은 용어로 사용되어, 두번째 방법은 역 시나리오에 적합합니다. 필드 안에 상대적으로 적은 용어가 Facet 되기를 바라는 경우죠.</p>

<h3>ElasticSearch</h3>

<p>On the other side we have ElasticSearch which allows us to do all that Solr can do (in terms of faceting calculation, not the calculation methods), but in addition it also let’s us exclude specific terms we are not interested in and use regular expressions to define which terms will be included in faceting results. In addition to that we can combine term faceting results from different field automatically or just use scripts to modify the fields values before the calculation process steps in</p>

<p>반면에 ElasticSearch 에서는 Solr 가 가능한 모든 것이 가능합니다. (Facet 계산에 관해서이며 계산방법은 그렇지 않습니다) 그리고 흥미없는 특정 용어를 배제할 수 있으며, Facet 결과에 포함된 용어의 정의에 정규표현을 사용할 수 있습니다. 또 다른 필드의 용어 faceting 의 결과를 자동적으로 연결하거나, 계산프로세스에 들어가기 전에 필드의 값을 변경하는 스크립트를 사용하거나 할 수 있습니다.</p>

<h2>Query Faceting</h2>

<p>Both Solr and ElasticSearch allow calculating faceting for arbitrary query results. In both cases queries can be expressed in the query API of the search engine which we use. For example, in ElasticSearch you can use the whole query DSL to calculate faceting results on them.</p>

<p>Solr 와 ElasticSearch 양 쪽 모두 임의의 쿼리의 결과에 대해서 Facet 을 계산할 수 있습니다. 양쪽 모두 쿼리는 검색엔진의 쿼리 API 로 표현할 수 있습니다. 예를들어 ElasticSearch 에서는 쿼리DSL 전체를 그 결과의 Facet 의 산출에 사용할 수 있습니다.</p>

<h2>Range Faceting</h2>

<p>Range faceting lets you get the number of documents that match the given range in a field. Both engines allow for range faceting although in different fashion.</p>

<p>Range Faceting 은 어떤 필드에 주어진 범위에 일치하는 도큐먼트의 수를 반환합니다. 두 엔진 모두 Range Faceting 이 가능하지만 서로 다른 방법으로 동작합니다.</p>

<h3>Solr</h3>

<p>Apache Solr lets you define the start value, end value, and the gap (with some adjustments like inclusion of values at the end of the ranges) and calculate all the ranges defined by that.</p>

<p>Apache Solr 는 시작과 끝의 값, 갭(과 몇가지 조정할 것, 예를들어 범위의 끝의 값은 포함되는가하는 것 이외 기타 등등)을 지정하고 그에 의해 정의된 모든 범위를 계산합니다.</p>

<h3>ElasticSearch</h3>

<p>ElasticSearch takes a different approach – it lets you specify set of ranges and returns document counts as well as aggregated data. In addition to that, ElasticSearch let’s you specify a different field to check if a document falls into a given range and a different field for the aggregated data calculation. Furthermore, you can modify the field and aggregated data with a script. And that’s not all – in addition to the above method of range faceting ElasticSearch also supports the so called histogram calculation.  This is similar to the Apache Solr approach – for a given field you can get a histogram of values. However, ElasticSearch doesn’t let you control the start and end like Solr does, but only the gap.</p>

<p>ElasticSearch 는 다른 접근방법을 취합니다. 범위의 집합을 지정해서 도큐먼트의 카운트와 집약된 데이터를 반환합니다. 그리고 ElasticSearch 는 다른 필드를 지정해서, 도큐먼트가 지정된 범위에 해당하는지 체크하는 것 이외에 집약데이터의 계산에 다른 필드를 지정할 수 있습니다. 또한, 필드와 집약데이터를 스크립트로 변경할 수 있습니다. 그것뿐만 아니라 위의 Range Faceting 에 이어 ElasticSearch Histogram 계산이라고 불리는 것도 이용할 수 있습니다. 이는 Apache Solr 의 접근방법과 비슷하게 주어진 필드의 값의 히스토그램을 얻을 수 있습니다. 그러나 ElasticSearch 는 Solr 처럼 시작값과 마지막값을 컨트롤할 수 없으며, 갭만 가능합니다.</p>

<h2>Date Faceting</h2>

<p>Again, both search engines support faceting on date based fields.</p>

<p>마찬가지로 두 검색엔진은 필드에 기반한 날짜 Faceting 을 지원합니다.</p>

<h3>Solr</h3>

<p>Date faceting in Apache Solr is quite similar to the range faceting, although it is calculated on fields of  solr.DateField type. You have the same control and use similar parameters as withing the range faceting so I’ll omit describing it.</p>

<p>Apache Solr 의 Date Faceting 은 Range Faceting 과 완전히 같지만 solr.DateField 타입의 필드상에서 계산됩니다. Range Faceting 과 같은 컨트롤이 가능하고, 같은 파라메터를 사용할 수 있습니다. 그때문에 여기에서는 자세한 서술은 생략합니다.</p>

<h3>ElasticSearch</h3>

<p>On the other hand, we have ElasticSearch with its date faceting which is an enhancement over the standard histogram faceting. It supports interval specification with date specific parameters like for example: year, month, or day. In addition to that, ElasticSearch lets you specify the time zone to be used in computation and of course manipulate the calculation with the use of a script.</p>

<p>반면 ElasticSearch 에서 Date Faceting 은 표준 Histogram Faceting 의 확장으로 동작합니다. 날짜를 특정하는 year, month, day 같은 파라메터와 간격을 지정할 수 있습니다. 그리고 ElasticSearch 는 연산에 사용되는 타임존 지정이 가능하며, 물론 스크립트를 이용해서 계산을 컨트롤할 수 도 있습니다.</p>

<h3>Decision Tree Faceting – Solr Only</h3>

<p>One of the things that ElasticSearch lacks and that is present in Solr is the pivot faceting aka decision tree faceting. It basically lets you calculate facets inside a parents facet. For example, this is what pivot faceting results look like in Solr (n.b. this example is trimmed for this post) :</p>

<p>현시점에서 Solr 에 존재하지만 ElasticSearch 에서는 빠진 것 중 하나가 pivot Faceting 또는 결정트리 Faceting 이라고 불리는 것입니다. 이것은 부모 Faceting 내부에서 Faceting 을 계산할 수 있습니다. 아래가 Solr 에서 Pivot Faceting 이 어떻게 동작하는 지에 관한 예제입니다(이 예제는 이 글을 위해서 일부 삭제하였습니다).</p>
<div class="highlight"><pre><code class="text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;response&gt;
&lt;lst name=&quot;responseHeader&quot;&gt;
  &lt;int name=&quot;status&quot;&gt;0&lt;/int&gt;
  &lt;int name=&quot;QTime&quot;&gt;1&lt;/int&gt;
  &lt;lst name=&quot;params&quot;&gt;
    &lt;str name=&quot;facet&quot;&gt;true&lt;/str&gt;
    &lt;str name=&quot;indent&quot;&gt;true&lt;/str&gt;
    &lt;str name=&quot;facet.pivot&quot;&gt;inStock,cat&lt;/str&gt;
    &lt;str name=&quot;q&quot;&gt;*:*&lt;/str&gt;
    &lt;str name=&quot;rows&quot;&gt;0&lt;/str&gt;
  &lt;/lst&gt;
&lt;/lst&gt;
&lt;result name=&quot;response&quot; numFound=&quot;32&quot; start=&quot;0&quot;&gt;
&lt;/result&gt;
&lt;lst name=&quot;facet_counts&quot;&gt;
  &lt;lst name=&quot;facet_queries&quot;/&gt;
  &lt;lst name=&quot;facet_fields&quot;/&gt;
  &lt;lst name=&quot;facet_dates&quot;/&gt;
  &lt;lst name=&quot;facet_ranges&quot;/&gt;
  &lt;lst name=&quot;facet_pivot&quot;&gt;
    &lt;arr name=&quot;inStock,cat&quot;&gt;
      &lt;lst&gt;
        &lt;str name=&quot;field&quot;&gt;inStock&lt;/str&gt;
        &lt;bool name=&quot;value&quot;&gt;true&lt;/bool&gt;
        &lt;int name=&quot;count&quot;&gt;17&lt;/int&gt;
        &lt;arr name=&quot;pivot&quot;&gt;
          &lt;lst&gt;
            &lt;str name=&quot;field&quot;&gt;cat&lt;/str&gt;
            &lt;str name=&quot;value&quot;&gt;electronics&lt;/str&gt;
            &lt;int name=&quot;count&quot;&gt;10&lt;/int&gt;
          &lt;/lst&gt;
          &lt;lst&gt;
            &lt;str name=&quot;field&quot;&gt;cat&lt;/str&gt;
            &lt;str name=&quot;value&quot;&gt;currency&lt;/str&gt;
            &lt;int name=&quot;count&quot;&gt;4&lt;/int&gt;
          &lt;/lst&gt;
          .
          .
          .
        &lt;/arr&gt;
      &lt;/lst&gt;
      &lt;lst&gt;
        &lt;str name=&quot;field&quot;&gt;inStock&lt;/str&gt;
        &lt;bool name=&quot;value&quot;&gt;false&lt;/bool&gt;
        &lt;int name=&quot;count&quot;&gt;4&lt;/int&gt;
        &lt;arr name=&quot;pivot&quot;&gt;
          &lt;lst&gt;
            &lt;str name=&quot;field&quot;&gt;cat&lt;/str&gt;
            &lt;str name=&quot;value&quot;&gt;electronics&lt;/str&gt;
            &lt;int name=&quot;count&quot;&gt;4&lt;/int&gt;
          &lt;/lst&gt;
          &lt;lst&gt;
            &lt;str name=&quot;field&quot;&gt;cat&lt;/str&gt;
            &lt;str name=&quot;value&quot;&gt;connector&lt;/str&gt;
            &lt;int name=&quot;count&quot;&gt;2&lt;/int&gt;
          &lt;/lst&gt;
          .
          .
          .
        &lt;/arr&gt;
      &lt;/lst&gt;
    &lt;/arr&gt;
  &lt;/lst&gt;
&lt;/lst&gt;
&lt;/response&gt;
</code></pre></div>
<h2>Statistical Faceting</h2>

<p>Both ElasticSearch and Apache Solr can compute statistical data on numeric fields – values like count, total, minimal value, maximum value, average, etc. can be computed.</p>

<p>ElasticSearch 와 Apache Solr 양쪽 모두가 통계 데이터를 수치 필드 위에서 계산할 수 있습니다. 예를 들어, 카운트, 총계, 최소값, 최대값, 평균값 등을 계산할 수 있습니다.</p>

<h3>Solr</h3>

<p>In Apache Solr the functionality that enables you to calculate statistics for a numeric field is called Stats Component. It returns the above mentioned values as a part of the query result, in a separate list, just as faceting results.</p>

<p>Apache Solr 에서는 수치필드에서 통계를 계산하는 기능은 stats 컴포넌트라고 불립니다. 위에서 적은 값을 쿼리의 결과의 일부로 별도의 리스트 안에 Faceting 결과로 반환합니다.</p>

<h3>ElasticSearch</h3>

<p>In ElasticSearch this functionality is called Statistical Facet. You should keep in mind thought that, as usual, ElasticSearch allows us to calculate this information for values returned by a script or combined for multiple fields, which is very nice if you need combined information for two or more fields or you want to do additional processing before getting the data returned by ElasticSearch.</p>

<p>ElasticSearch 에서는 이 기능은 statistical Faceting 이라고 부릅니다. 기억해두어야 할 것은 ElasticSearch 는 이 정보를 스크립트의 반환값에 대해서 계산하거나, 여러 필드의 결합 시에 계산할 수 있다는 것입니다. 2개 이상의 필드의 결합정보가 필요하거나, ElasticSearch 에서 반환된 값을 얻기 전에 추가적인 처리를 실행하고자 하는 경우에 매우 편리합니다.</p>

<h2>Geodistance Faceting</h2>

<p>(Geo)spatial search is quite popular nowadays where we try to provide the best search results we can and we considering multiple pieces of information and conditions. Of course both Apache Solr and ElasticSearch provide spatial search capabilities, but we are not talking about searching – we are talking about faceting. Sometimes there is a need to return a distance from a given point, just to show that in our application – and we can do that both in ElasticSearch and Solr.</p>

<p>(Geo)spatial 검색은 요즘 매우 인기가 있습니다. 우리는 가능한한 수치의 정보와 조건에 의한 최고의 검색결과를 얻을 수 있도록 노력하고 있습니다. 물론 Apache Solr 와 ElasticSearch 양쪽 모두 spatial 검색이 가능합니다. 그러나 지금은 검색이야기가 아니라 Faceting 이야기죠. 우리는 어플리케이션에서 때때로 주어진 지점에서 거리를 반환할 필요가 있습니다. ElasticSearch 와 Solr 모두 이런 것이 가능합니다.</p>

<h3>Solr</h3>

<p>In Solr to be able to facet by distance from a given point we would have to use facet.query parameter and use frange or geofilt, for example like this:</p>

<p>Solr 에서는 주어진 지점에서 거리로 Faceting 할 수 있습니다. facet.query 파라메터를 사용할 필요가 있으며 frange, geofilt 를 아래처럼 사용합니다.</p>
<div class="highlight"><pre><code class="text">q=*:*&amp;sfield=location&amp;pt=10.10,11.11&amp;facet=true&amp;facet.query={!geofilt d=10 key=d10}
</code></pre></div>
<p>This would return the number of document within 10 kilometers from the defined point.</p>

<p>이것은 정의된 지점에서 10km 이내의 도큐먼트의 수를 반환합니다.</p>

<h3>ElasticSearch</h3>

<p>ElasticSearch exposes dedicated geo_distance faceting type that lets us pass the point and the array of ranges we want the distance to be calculated for. An example query might look like this:</p>

<p>ElasticSearch 는 geo_distance Faceting 타입이 공개되어 있고, 이것을 사용해서 위치와 계산대상의 거리 범위를 배열로 건넵니다. 쿼리의 예제는 아래와 같습니다.</p>
<div class="highlight"><pre><code class="text">{
 &quot;query&quot; : {
  &quot;match_all&quot; : {}
 },
 &quot;facets&quot; : {
  &quot;d10&quot; : {
   &quot;geo_distance&quot; : {
    &quot;doc.location&quot; : {
     &quot;lat&quot; : 10.10,
     &quot;lon&quot; : 11.11
    },
    &quot;ranges&quot; : [
     { &quot;to&quot; : 10 }
    ]
   }
  }
 }
}
</code></pre></div>
<p>In addition to that, we can specify the units to be used in distance calculations (kilometers and miles) and the distance calculation type – arc for better precision and plane for faster execution.</p>

<p>그리고 거리의 계산에 사용하는 단위(Km 또는 마일)와 거리의 계산타입을 지정할 수 있습니다. arc 는 보다 나은 정밀도, 그리고 plane 은 계산이 빠릅니다.</p>

<h2>Solr, LocalParams and Faceting</h2>

<p>One of the good things about faceting in Solr is that it allows the use of local params. For example, you can remove some filters from the faceting results. Imagine you have a query that gets all results for a term ‘flower’ and you only get results that fall into ‘cloth’ category and ‘shirt’ subcategory, but you would like to have faceting for tags field not narrowed to any filter. With the help of local params this query may look like this:</p>

<p>Solr 의 Faceting 에 있어서 좋은 점 중 하나는 로컬파라메터를 사용할 수 있다는 것입니다. 예를들어 Faceting 의 결과에서 몇가지 필터를 삭제할 수 있습니다. <code>flower</code> 라는 용어에 대해서 모든 결과를 얻는 쿼리가 있을 경우 <code>cloth</code> 의 카테고리에서 <code>shirt</code> 의 서브카테고리만의 결과를 얻어야 한다고 합시다. 하지만 tags 필드에 대해서는 어느 필터에서도 조건을 취합하고 싶지는 않습니다. 로컬파라메터의 도움으로 다음과 같은 쿼리를 만들 수 있습니다.</p>
<div class="highlight"><pre><code class="text">q=flower&amp;fq={!tag=facet_cat}category:cloth&amp;fq={!tag=facet_sub}subcategory:shirt&amp;facet=true&amp;facet.field={!ex=facet_cat,facet_sub}tags
</code></pre></div>
<h2>ElasticSearch Faceting Scope and Filters</h2>

<p>By default ElasticSearch facets are restricted to the scope of a given query, which is understandable. However, ElasticSearch also lets us change the scope of faceting to global and thus calculate the faceting for the whole data set, and not just for a given result set. In addition to that we can calculate facets for different nested objects by defining the scope matching the name of the nested object. This can come in handy in many situations, for example when optimizing memory usage on faceting on multivalued fields with many unique terms. In addition to that with ElasticSearch we can narrow down the subset of the documents on which faceting will be applied by using filters. We can define filters inside faceting (just please remember that filters that narrow down query results are not restricting faceting) and choose which documents should be taken into consideration when calculating facets. Of course, as you may expect, filters for faceting may be defined in the same way as filters for queries.</p>

<p>기본적으로는 ElasticSearch 의 Faceting 은 주어진 쿼리의 범위에 한정됩니다. 이해할 수는 있지만 ElasticSearch 는 Faceting 의 범위를 글로벌하게 변경가능하고, 주어진 결과집합만이 아닌 모든 데이터셋에 대해서 Faceting 을 계산할 수 있습니다. 그리고 다른 중첩오브젝트에 대해서 Faceting 을 계산할 수도 있습니다. 중첩 오브젝트의 이름에 일치하는 범위를 정의합니다. 이는 대부분의 경우에 편리합니다. 예를 들어 많고 다양한 용어와 여러값을 가진 필드에 대해서 Faceting 을 할 시, 메모리를 최적화해야할 경우입니다. ElasticSearch 에서는 필터를 사용함으로써 Faceting 을 적용할 도큐먼트의 부분집합을 뽑아낼 수 있습니다. Faceting 의 내부에서 필터를 설정가능하고(쿼리 결과를 묶는 필터는 Faceting 만으로 한정되지 않는 것을 기억해주세요) 어느 도큐먼트가 Faceting 을 계산할 시에 고려해야할 것인가를 선택할 수 있습니다. 물론 예상되겠지만, Faceting 에 대한 필터는 쿼리에 대해서 필터처럼 정의할 수 있습니다.</p>

<h2>정리</h2>

<p>In this part of the Apache Solr vs ElasticSearch posts series we talked about the ability to calculate facet information and only about this. Of course, this is only a look at the surface of faceting, because both Apache Solr and ElasticSearch provide some additional parameters and features that we couldn’t cover without turning this post into a tl;dr monster. However, we hope this post gives you some general ideas about what you can expect from each of these search engines. In the next part of the series we will focus on other search features, such as geospatial search and the administration API. If you are going to the upcoming ApacheCon EU and are interested in hearing more about how ElasticSearch and Apache Solr compare, please come to my talk titled “Battle of the giants: Apache Solr 4.0 vs ElasticSearch“. See you there!</p>

<p>Apache Solr vs. ElasticSearach 시리즈의 이번 파트에서는 Faceting 정보의 계산에 대해서만 이야기했습니다. 물론 이는 Faceting 의 표면만을 다룬 것에 지나지 않습니다. Apache Solr 와 ElasticSearch 양쪽에 좀 더 추가적인 파라메터와 기능이 더 많이 존재하지만 모든 것을 커버하기에는 현재로는 어렵네요. 하지만 이 글이 각 검색엔진에 무엇을 기대할 것인가 하는 일반적인 생각을 얻을 수 있을 것입니다. 다음편에서는 별도의 검색기능인 geospatial 검색과 관리용 API 에 대해서 다룰 예정입니다. 만약 이번 ApacheCon EU 에 오고 ElasticSearch 와 Apache Solr 비교에 대해서 보다 자세히 듣고 싶다면 내 강연(타이틀은 &ldquo;Battle of the giants : Apache Solr 4.0 vs ElasticSearch&rdquo;)를 들으러 오세요. 거기서 만나요!</p>

<ul>
<li>@kucrafal, @sematext</li>
</ul>
</div>

  <footer>
    
    <p><a class="comments-link" href="/2013/07/16/solr-vs-elasticsearch-part-4-faceting/#disqus_thread" data-disqus-identifier="http://jeen.github.io/2013/07/16/solr-vs-elasticsearch-part-4-faceting/">View comments &raquo;</a></p>

    
    
  </footer>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/page/2">&larr; Older</a>
    
    <a href="/archives">Blog Archives</a>
    
  </div>
</div>

<aside class="sidebar">
  
    






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Jeen Lee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'jeen';
      var disqus_developer = '0';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



  
<div id="fb-root"></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>


  

  





</body>
</html>
