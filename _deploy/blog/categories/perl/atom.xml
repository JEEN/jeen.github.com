<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: perl | Jeen's techlog]]></title>
  <link href="http://jeen.github.com/blog/categories/perl/atom.xml" rel="self"/>
  <link href="http://jeen.github.com/"/>
  <updated>2013-04-28T19:05:55+09:00</updated>
  <id>http://jeen.github.com/</id>
  <author>
    <name><![CDATA[Jeen Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rex Common Practice]]></title>
    <link href="http://jeen.github.com/blog/2013/04/28/more-rex/"/>
    <updated>2013-04-28T18:32:00+09:00</updated>
    <id>http://jeen.github.com/blog/2013/04/28/more-rex</id>
    <content type="html"><![CDATA[<h3>Parallelism 설정</h3>

<p> 한 손에 셀 수 있을 정도의 서버규모라면 사실 특별하게 병렬처리를 하느니 하는 것은 별로 고려하지 않아도 되겠습니다만, 그 이상일 경우에는 한 작업을 수행함에 있어서 수십대의 서버에 순차적으로 접속하고 작업하고하는 것을 지켜보는 것은 상당히 고역이죠.
 이럴 경우에는 <code>parallelism</code> 을 지정합니다.</p>

<p> 방법은 <code>Rexfile</code> 에 다음과 같이 설정합니다.</p>

<p><code>
parallelism =&gt; 10;
</code></p>

<p> 이렇게 하면 한번에 10대의 서버에 대해서 병렬로 작업을 수행하게 됩니다. 어차피 작업은 원격지서버에서 하는 것이고, 로컬에서는 SSH 커넥션이 1개로 붙던 것들이 10개로 늘어나며, 물론 시간 또한 parallelism 설정갯수에 비례하게 됩니다. 하지만 로그는 이쁘게 남지는 않을 겁니다.</p>

<p> 애시당초 CLI 옵션에 <code>parallelism</code> 옵션이 있었으면 좋겠는데...</p>

<h3>Logging</h3>

<p> 일단 작업 기록은 꾸준히 남기는 것이 좋겠다라고 생각하는 바, 매 작업분기마다 로그를 남기도록 합니다. 하지만 매뉴얼에는 마땅히 로그에 관한 설명은 보이지 않는 것 같았습니다.</p>

<p> Rex 에서의 기본적인 로그를 쓰는 방법은 다음과 같습니다.</p>

<p><code>
Rex::Logger::info("MSG"[, "TYPE"]);
</code></p>

<p> 로그 메시지는 당연히 필수이며, TYPE 은 사실 안써도 됩니다만, error/warn 두가지 인수를 넣을 수 있습니다. 에러 상황시 확실하게 눈에 띄게 해주는 정도(노랑색, 빨강색)입니다.</p>

<p> Parallelism 사용시에 병렬로 작업을 수행함으로 인해서 로그가 뒤죽박죽이 되기 마련인데, 이때 로그에 명기해주었으면 하는 것은 역시 각 서버의 호스트/IP입니다.</p>

<ul>
<li><a href="https://metacpan.org/module/Rex::Logger">https://metacpan.org/module/Rex::Logger</a></li>
</ul>


<p> <code>Rex::Logger</code> 에서 다음과 같은 사용법을 통해서 해결할 수 있습니다.</p>

<p>```
$Rex::Logger::format = '%h - %D - %s';</p>

<h1>srv001 - 2012-04-12 18:35:12 - Installing package vim</h1>

<p>```</p>

<p> 각 포맷에 대한 자세한 설명은 위의 Metacpan 링크에서 확인할 수 있습니다.</p>

<h3>CPAN 의존모듈 설치</h3>

<p> 애시당초 처음에 Rex 를 사용하는 이유가 여러대의 서버에 CPAN 모듈을 설치해야할 필요가 있었기 때문이었습니다. 하지만 사용구조상 일일이 모든 서버에 대해서 <code>perlbrew</code> 를 설치한다거나, 하는 호화(?)를 누릴 수는 없었습니다. <code>perlbrew</code> 를 꺼내는 것 자체가 애시당초 핀트에 어긋나버리는 얘기가 되어버리지만… -_-;</p>

<p> 뭐 네, 방법은 간단합니다.</p>

<p><code>
run("curl -L http://cpanmin.us | perl - --notest --mirror ftp://cpan.mirror.cdnetworks.com/CPAN/ --mirror-only Test::More LWP::UserAgent JSON Nagios::Plugin");
</code></p>

<p> 애시당초 Rex 의 접근은 <code>root</code> 로 이뤄지기 때문에 이와같은 설정으로 그냥 땜박질 할 수 있었지만, <code>sudo</code> 로 접근한다거나 하는 예외상황에서는 <code>--sudo</code> 옵션을 붙여주면 되겠습니다. 물론 <code>root</code> 로 접근했을 때 <code>--sudo</code> 옵션은 쓰면 오동작의 원인이 됩니다.</p>

<p> <code>--notest</code> 는 물론 수많은 서버가 동일 구성이며, 처음 커맨드로 때려보고 한방에 된다고 했을 때, 테스트가 불필요하다는 판단아래에서 집어넣었구요.</p>

<p> 좀 더 속도개선을 노려본다면 <code>--mirror</code> 옵션을 통해서 <code>CDNetworks</code> 같은 CPAN Mirror 를 이용해보는 것도 괜찮을 것 같습니다. 눈에 띄는 속도향상을 체감할 수 있을 겁니다.</p>

<h3>결론</h3>

<p> 어떤 일을 하기에 필요한 도구를 찾아서 사용하는 것이 일반적인 접근일텐데, 때로는 어떤 도구를 사용하기 위해서 일부러 일을 그쪽방향으로 맞추는 경우를 주변에서 많이 접하게 됩니다. 저는 어떻게해서 Rex 를 알고 사용하게 되었는지 이미 까먹었지만, 하는 일에 대한 최적의 선택이었다고 생각합니다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data::Printer vs Data::Dump(er)]]></title>
    <link href="http://jeen.github.com/blog/2013/04/08/data-printer-vs-data-dump-er/"/>
    <updated>2013-04-08T12:59:00+09:00</updated>
    <id>http://jeen.github.com/blog/2013/04/08/data-printer-vs-data-dump-er</id>
    <content type="html"><![CDATA[<p> 여태껏 많은 Perl 코드에서 습관적으로 <code>Data::Dumper</code> 를 사용해왔습니다.</p>

<blockquote><p>안되면 찍어봐라</p></blockquote>

<p> 라는 가장 기본적인 디버깅 방법론을 <code>Data::Dumper</code> 와 함께 해왔었죠. 물론 코어모듈이기때문에 별다른 모듈 설치없이 그냥 사용할 수 있는 점이 가장 큰 매력이었습니다.</p>

<p> 단순한 데이터구조에서는 빛을 발하지만, 이런저런 데이터들이 서로 어우러지고 구겨지고 하는 구조에 한글과 같은 멀티바이트문자가 들어갔을 때는 사정없이 깨져버리는 문제가 있습니다. 물론 회피책도 있기는 하지만 매번 그러기도 쉽지가 않죠. 기존의 많은 <code>Data::Printer</code> 에도 언급되었다시피, <code>DBIx::Class</code> 오브젝트를 찍어보는 것에 매우 효과적입니다. <code>DateTime</code> 도 마찬가지 입니다. 이는 <code>DBIx::Class</code> 나 <code>DateTime</code> 을 <code>Data::Dumper</code> 로 찍어본 사람이라면 누구나 느껴봤을 법한 것이죠.</p>

<p> 아무튼 그래서 <code>Data::Printer</code> 를 사용하기 시작했습니다. 현재 회사에서는 이전과는 달리 웹개발에 메인으로 Perl 을 사용하지 않고 주로 여러가지 배치작업이나 스크래핑 작업 용도로 사용하고 있어서 주로 사용하는 모듈을 그냥 처음부터 집어넣고 시작하고 있습니다.</p>

<p><img src="https://dl.dropboxusercontent.com/u/262117/blog-assets/screenshot-201304112.png" alt="https://dl.dropboxusercontent.com/u/262117/blog-assets/screenshot-201304112.png" /></p>

<p> 그리고 결정적으로 키와 값의 색 구분이라든가, 배열의 인덱스 번호를 좌르륵 이라든가, 한글이 안깨진다든가…</p>

<p> 단점은 없는 게 아닙니다. 그러니까 좀 규모가 있는 데이터를 <code>Data::Printer</code> 로 덤프하면 그 나름대로 치장하는 시간이 좌르르륵 올라갑니다. 근데 뭐 그런 규모있는 데이터를 <code>Data::Printer</code> 로 뽑는 것 자체가 이상한 일이라 -_-;;</p>

<p> 아 그리고 <code>Data::Printer</code> 의 <code>p</code> 함수는 기본적으로 인자를 기본형만 받을 수 있습니다.</p>

<p><code>
p [{ a =&gt; 1 }]
</code></p>

<p>이라고 했을 때,</p>

<p><code>
Type of arg 1 to Data::Printer::p must be one of [@$%&amp;]
</code></p>

<p>라는 에러메시지가 나옵니다.</p>

<p> 아 그리고 <code>Data::Printer</code> 의 출력은 기본적으로 STDERR 로 나옵니다. 물론 뭐 하고 싶다면야 STDOUT 으로 지정할 수 있습니다.</p>

<ul>
<li><a href="https://metacpan.org/module/Data::Printer#Changing-output-targets">https://metacpan.org/module/Data::Printer#Changing-output-targets</a></li>
</ul>


<p> <code>Data::Printer</code> 와 함께 깔끔한 디버깅을...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Rex - Environment]]></title>
    <link href="http://jeen.github.com/blog/2013/04/04/using-rex-environment/"/>
    <updated>2013-04-04T12:28:00+09:00</updated>
    <id>http://jeen.github.com/blog/2013/04/04/using-rex-environment</id>
    <content type="html"><![CDATA[<p> 주위 사람들은 Chef나 Fabric 을 많이 쓴다고 하지만 ( 그보다 손으로 여전히 하는 사람들이 더 많은 것 같기도 ), Rex 에 그냥 적응하면서 여전히 <a href="http://rexify.org">Rex</a> 를 사용하고 있습니다. 회사를 옮기고 새로운 작업환경을 둘러보다가 이전의 패턴이 그대로 먹히지 않기에 기존에 사용하던 Rexfile 의 구조도 살며시 바꿔나가야 했습니다.</p>

<h2>Rex 초기 설정</h2>

<p> Rex 가 설치되어 있다면, <code>rexify</code> 커맨드를 사용할 수 있습니다. 이 커맨드를 이용해서 초기 뼈대를 만들어 봅니다.</p>

<p><code>
$ rexify M
</code></p>

<p>그러면 아래와 같은 구성으로 Rex 를 사용하기 위한 기본 구성이 마련됩니다.</p>

<p>```
$ tree
.
├── Rexfile
└── lib</p>

<pre><code>└── M.pm
</code></pre>

<p>```</p>

<p><code>Rexfile</code> 에는 온갖 설정 정보를 넣고, M.pm 에는 각 Task 를 정의해둡니다.</p>

<h2>서버 그룹 위의 또 다른 그룹을 정의한다?</h2>

<p>　지금까지는 서버의 목적, 그러니까 <code>DB</code> 서버 면 <code>DB</code> 그룹에 , <code>Web</code> 서버면 <code>Web</code> 그룹에 묶으면 되었는데요. 하지만 현재의 회사에서는 서비스그룹이 나뉘어져 있기도 하고, 계정정보도 좀 다르기도 하고 그런 게 있습니다. -_-;</p>

<p> 그래서 <code>environment</code> 로 각 그룹을 묶어서 별도로 관리하기로 했습니다.</p>

<p> 그런 것을 고려해서 써놓은 Rexfile 은 아래와 같습니다.</p>

<p>```
use Rex -feature => 0.40;</p>

<p>environment sdt => sub {</p>

<pre><code>set user =&gt; "xxxx";
set password =&gt; "xxxxxx";
set -passauth;

set group =&gt; "all" =&gt; qw/1.2.3.51 1.2.3.52 1.2.3.53 1.2.3.54 1.2.3.55 1.2.3.56/;
set group =&gt; "db"  =&gt; qw/1.2.3.53 1.2.3.54/;
set group =&gt; "web" =&gt; qw/1.2.3.51 1.2.3.52 1.2.3.55 1.2.3.56/;
</code></pre>

<p>};</p>

<p>environment pshd => sub {</p>

<pre><code>set user =&gt; "xxxx";
set password =&gt; "xxxxxxxx";
set -passauth;
set group =&gt; "all" =&gt; qw/1.2.4.31 1.2.4.32 1.2.4.33 1.2.4.34 1.2.4.35 1.2.4.36/;
set group =&gt; "db"  =&gt; qw/1.2.4.35 1.2.4.36/;
set group =&gt; "web" =&gt; qw/1.2.4.31 1.2.4.32 1.2.4.33 1.2.4.34/;
</code></pre>

<p>};</p>

<p>require M;
```</p>

<p>이렇게 <code>sdt</code> 와 <code>pshd</code> 라는 environment 를 따로 빼놓고 그 안에 각각 전체와 Web, DB 각각을 정의해둡니다.</p>

<p> <code>M.pm</code> 에는 <code>restart-opsview-agent</code>, <code>restart-munin-node</code>, <code>restart-apache</code>, <code>deploy-apps</code> 같은 뭐 이런저런 Task 들이 정의되어 있다고 치고…</p>

<p> 그런 것들을 각 environment 의 그룹단위로 실행시키도록 합니다.</p>

<p><code>
$ rex -E sdt -G all M:restart-opsview-agent
</code></p>

<p> 위처럼 <code>-E</code> 의 인자값으로 environment 를 지정하고 <code>-G</code> 의 인자값으로 all 그룹을 지정해줌으로써, sdt 의 전체 서버에 대해서 <code>opsview-agent</code> 를 재시작하게끔 합니다.</p>

<h2>결론</h2>

<p> 사실은 뭐 각 서버에 SSH Key 를 박아넣고 사용해야 좀 더 안심이 되기도 하지만, 여기에는 뜻모를 어른들의 사정이 숨어져 있는지라 쉽게 그럴수는 없기도 하답니다. -_-; 좀 더 시간을 두고 뭐 여러가지 불안요소와 편의성을 도모하기로 하고…</p>

<p> 터미널 사용에 익숙하지 않은 팀원들을 위해서 <code>Rex::WebUI</code> 도 살며시 검토해봤는데, 아직까지는 Task 에 기재된 정보를 기준으로 읽어들이는 것 밖에 되지 않는지라… 위처럼 그룹을 지정하거나 environment 를 지정하거나 하는 것은 불가능하군요. 뭐 어차피 서버 데몬을 아무나 만지게 하고 그러는 것도 조심스러운 지라… -_-;; 꼭 모두가 써야하는 것인가 하는 의문이 있어서, 이건 뭐 전제자체가 붕괴되는 군요.</p>

<p> 아무튼 Rex 괜찮습니다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cpanm 1.6 is here for you]]></title>
    <link href="http://jeen.github.com/blog/2013/02/28/cpanm-1-dot-6-is-here-for-you/"/>
    <updated>2013-02-28T09:34:00+09:00</updated>
    <id>http://jeen.github.com/blog/2013/02/28/cpanm-1-dot-6-is-here-for-you</id>
    <content type="html"><![CDATA[<p> 엊그제 cpanm 1.6 이 릴리즈되었습니다. 그동안 개발버젼으로 1.6에 포함될 기능들이 일부 소개되어 왔지만, 아무튼 뭐 @miyagawa 씨가 친히 Screencast 까지 준비해서 소개할 정도로 많은 기능들이 추가되었습니다.</p>

<p> <iframe width="560" height="315" src="http://www.youtube.com/embed/6Vglyf7X2S8" frameborder="0" allowfullscreen></iframe></p>

<h2>버젼지정 설치</h2>

<p><code>
$ cpanm MIYAGAWA/Plack-1.0015.tar.gz
</code></p>

<p>위처럼 번거로운 버젼지정 설치방식이</p>

<p><code>
$ cpanm Plack@1.0015
</code></p>

<p>이렇게 간단해졌습니다.</p>

<p>예전에 <code>Mail::Sender</code> 의 마이너버젼에 따라서 인코딩지정이 좀 엉망이 되어서 우회코드를 쓸 까 하다가</p>

<p>그냥 증상이 나타나기 이전버젼으로 땜빵으로 버티던 기억이 있습니다. (물론 해당 버젼의 동작이 이상해서 뭐 금방 업데이트 되었었지만…)</p>

<h2>개발버젼 설치</h2>

<p><code>
$ cpanm --dev Plack
</code></p>

<p><code>--dev</code> 옵션을 이용하여 개발버젼의 모듈을 설치할 수 있습니다.</p>

<p>저같은 경우는 요즘 거의 개발버젼을 보고 사용하는 경우가 없어서 쓸 일은 없을 것 같습니다.</p>

<ul>
<li>버젼범위 지정</li>
</ul>


<p> 1.0000 이상 2.0000 미만의 Plack 모듈 설치</p>

<p><code>
$ cpanm Plack~"&gt;= 1.0000, &lt; 2.0000"
</code></p>

<p> 1.0000 버젼의 Plack 설치 (<code>cpanm Plack@1.0000</code> 과 동일합니다.)</p>

<p><code>
$ cpanm Plack~"== 1.0000"
</code></p>

<p> 1.0000 이상이지만 1.0016 버젼은 제외한 가장 최신의 Plack 모듈 설치</p>

<p><code>
$ cpanm Plack~"&gt;= 1.0000, != 1.0016"
</code></p>

<p>사실 <code>Makefile.PL</code> 에 의존모듈들을 넣었을 때 위와 같은 표기가 필요할 경우가 발생할 수 있겠습니다만, 대개의 경우는 특정 버젼만 지정해서 사용하는 경우가 많았기 때문에 어떨런지 잘 모르겠습니다.</p>

<h2>Git Repository 에서 받아서 설치</h2>

<p> 몇몇 CPAN Author 들을 보면, CPAN 에 올릴 만큼 정비되지 않았다는 이유로 Github 에만 공개해놓는 경우를 많이 볼 수 있습니다. 몇번 그런 경우가 있었고, 일부러 다른 툴을 사용해서 Github 에서 CPAN Module 을 설치했던 기억도 있습니다. 이제부터 cpanm 이 이런 케이스를 지원해주니 다행이군요.</p>

<p> 기본 브랜치를 설치</p>

<p><code>
$ cpanm git://github.com/JEEN/p5-WebService-Aladdin.git
</code></p>

<p> devel 브랜치를 설치</p>

<p><code>
$ cpanm git://github.com/JEEN/p5-WebService-Aladdin.git@devel
</code></p>

<p> 특정 커밋내용이 적용된 부분을 설치</p>

<p><code>
$ cpanm git://github.com/JEEN/p5-WebService-Aladdin.git@730fbd0a80
</code></p>

<h2>결론</h2>

<p> perlbrew 에서 <code>perlbrew install-cpanm</code> 으로 설치된 cpanm 을 사용하고 있었는데,</p>

<p><code>
$ cpanm --self-upgrade
</code></p>

<p> 로는 perlbrew 를 통해서 설치된 cpanm 의 버젼이 바뀌지 않는군요. 그럴 경우는,</p>

<p><code>
$ perlbrew install-cpanm
</code></p>

<p> 을 통해서 기존의 cpanm 을 덮어써서 설치할 수 있습니다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A usecase of App::Fatpacker - Nagios Plugin]]></title>
    <link href="http://jeen.github.com/blog/2012/12/26/a-usecase-of-app-fatpacker/"/>
    <updated>2012-12-26T23:48:00+09:00</updated>
    <id>http://jeen.github.com/blog/2012/12/26/a-usecase-of-app-fatpacker</id>
    <content type="html"><![CDATA[<p> 최근 업무때문에 Nagios Plugin 을 만져야 하는 일들이 빈번하게 있었고, 앞으로도 발생할 소지가 상당히 높습니다. 이런 Nagios Plugin 을 만들거나 기존에 만들어 진 것들을 간편하게 다른 복수의 서버에 배포하는 일도 필요합니다.</p>

<p> Nagios Plugin 이야 굳이 언어를 가리지 않는다고 치더라도, 언어의 특정 라이브러리에 의존을 가지는 경우가 많습니다. MongoDB 용 Nagios Plugin 에는 Python 의 pymongo 라이브러리를 설치해야하는 경우가 있지요.</p>

<p> 일례로 Redis 용 Nagios Plugin 을 설치할 시에는 Redis CPAN 모듈을 필요로 합니다. 그런데 Redis 서버가 여러대이고, 이 여러대의 서버에 매번 Redis 모듈을 깔고, Redis 모니터링용 Nagios Plugin 도 설치를 해야하는 경우가 있습니다. 그냥 뭐 시간을 좀 허비해서라도 그렇게 번거로운 일을 하면 일이야 끝나겠지만, 현인(@aer0 님)의 조언을 빌어서 <a href="http://metacpan.org/module/App::FatPacker">App::FatPacker</a> 를 사용해서 단일 스크립트에 우겨넣는 방향으로 돌리도록 합니다.</p>

<p> 우선은 <code>App::FatPacker</code> 를 설치하면 <code>fatpack</code> 이라는 커맨드를 사용할 수 있습니다.</p>

<p> <a href="http://exchange.nagios.org">Nagios Exchange</a> 에서 찾아낸 <a href="http://exchange.nagios.org/directory/Plugins/Databases/check_redis-2Epl/details">check_redis</a> 중에 <code>check_redis.pl</code> 파일이 위에 말한대로 Redis 모듈에 의존이 걸린 상황입니다.</p>

<p> 그럼 우선 <code>fatpack</code> 커맨드로 다음과 같이 입력을 합니다.</p>

<p><code>bash
$ fatpack trace check_redis.pl
check_redis.pl syntax OK
</code>
 결과 <code>syntax OK</code> 가 뜨고 해당 디렉토리에 <code>fatpacker.trace</code> 라는 파일이 생성됩니다.</p>

<p><code>bash
$ cat fatpacker.trace
IO/Handle.pm
List/Util.pm
Getopt/Long.pm
SelectSaver.pm
IO/Socket.pm
Fcntl.pm
Text/ParseWords.pm
Symbol.pm
Scalar/Util.pm
IO/Socket/INET.pm
Errno.pm
fields.pm
warnings/register.pm
Encode/Alias.pm
Time/HiRes.pm
Encode/Config.pm
Encode/Encoding.pm
Redis.pm
Encode.pm
base.pm
Config.pm
IO.pm
IO/Socket/UNIX.pm
Carp.pm
bytes.pm
Exporter/Heavy.pm
vars.pm
constant.pm
Socket.pm
Try/Tiny.pm
IO/Select.pm
overload.pm
lib.pm
DynaLoader.pm
Data/Dumper.pm
</code></p>

<p>내용을 보면 말 그대로 해당 모듈이 가지고 있는 의존 모듈이 좌르르륵 표시됩니다. 물론 걔중에는 Core 모듈도 있기도 합니다.</p>

<p> 일단 <code>App::FatPacker</code> SYNOPSIS 대로 진행을 해보면…</p>

<p><code>bash
$ fatpack packlists-for `cat fatpacker.trace`  &gt; packlists
</code></p>

<p>위 결과로 생긴 <code>packlists</code> 는 파일은 다음과 같은 내용을 가집니다.</p>

<p><code>bash
$ cat packlists
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/5.14.0/x86_64-linux-thread-multi/auto/Time/HiRes/.packlist
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/x86_64-linux-thread-multi/auto/Redis/.packlist
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/x86_64-linux-thread-multi/auto/Try/Tiny/.packlist
</code></p>

<p>각 의존 모듈 위치에 맞춰서 <code>.packlist</code> 파일이 생성되고, 그 내용은…</p>

<p><code>bash
$ cat /home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/x86_64-linux-thread-multi/auto/Redis/.packlist
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/Redis.pm
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/Redis/Hash.pm
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/Redis/List.pm
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/man/man3/Redis.3
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/man/man3/Redis::Hash.3
/home/jeen/perl5/perlbrew/perls/perl-5.14.0/man/man3/Redis::List.3
</code></p>

<p>위와 같습니다.</p>

<p>그리고 다음 커맨드를 입력해봅니다.</p>

<p><code>bash
$ fatpack tree `cat packlists`
</code></p>

<p>그 결과 현재 디렉토리에서 <code>fatlib</code> 이라는 디렉토리가 생성되고 그 안에 관련 의존모듈들이 복사됩니다.</p>

<p><code>bash
$ tree
…
├── fatlib
│   ├── Redis
│   │   ├── Hash.pm
│   │   └── List.pm
│   ├── Redis.pm
│   ├── Try
│   │   └── Tiny.pm
│   └── x86_64-linux-thread-multi
│       ├── Time
│       │   └── HiRes.pm
│       └── auto
│           └── Time
│               └── HiRes
│                   ├── HiRes.bs
│                   └── HiRes.so
…
</code></p>

<p>그럼 다음 커맨드를 입력해보면…</p>

<p><code>bash
$ (fatpack file; cat check_redis.pl ) &gt; check_redis.packed.pl
Can't stat /home/jeen/fp/tt/lib: 그런 파일이나 디렉터리가 없습니다
 at /home/jeen/perl5/perlbrew/perls/perl-5.14.0/lib/site_perl/5.14.0/App/FatPacker.pm line 200
BEGIN failed--compilation aborted at /home/jeen/perl5/perlbrew/perls/perl-5.14.0/bin/fatpack line 3.
</code></p>

<p>제대로 동작하지 않습니다. 에러가 발생하네요. 정답은 에러메시지에 있습니다. <code>App::FatPacker</code> 자체는 Perl Library 규칙에 정형화된 디렉토리 구조를 가정하고 있습니다. 즉 <code>lib</code> 디렉토리가 존재하지 않기 때문에 발생하는 것이죠. 뭐 물론 다운받은 <code>check_redis.pl</code> 파일 하나만 있는 데 <code>lib</code> 디렉토리를 가지고 뭐 더 넣고 자시고 할 것도 아닌데…, 그래도 뭐 일단 사태해결을 위해서 아무것도 없어도 그냥 <code>lib</code> 디렉토리 하나는 만들어 줍니다.</p>

<p>그리고 다시 실행해보면 <code>check_redis.packed.pl</code> 이라는 파일이 생성됩니다.</p>

<p>``` perl
 # This chunk of stuff was generated by App::FatPacker. To find the original
 # file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;</p>

<p>$fatpacked{"Redis.pm"} = &lt;&lt;'REDIS';
  package Redis;</p>

<p>  # ABSTRACT: Perl binding for Redis database
  our $VERSION = '1.955'; # VERSION
  our $AUTHORITY = 'cpan:MELO'; # AUTHORITY
  …
```</p>

<p> 일단 Nagios Plugin 은 기본 실행권한을 가지는 파일로 해두는 것이 여러모로 편합니다. 한가지 주의할 점은 일단 위처럼 생성된 파일에서 shebang line 이 존재하지 않기때문에 shebang line 을 추가해주면 됩니다. :-)</p>

<p><code>perl
 #!/usr/bin/env perl
</code></p>

<p> 위의 내용을 <code>check_redis.packed.pl</code> 파일의 첫째줄에 추가해줍니다.</p>

<p> 그리고 완성된 파일들을 Redis 서버에 붙여서 <code>check_nrpe</code> 등으로 동작을 확인하고 설정에 추가하는 것으로 관련된 작업은 끝이 났습니다.</p>

<p> 파일 중앙배포와 관련해서도 다양한 이슈가 있지만 이에 관련해서는 추후 <code>Rex</code> 를 다루면서 이야기를 계속할 까 합니다.</p>

<p> 다 쓰고 나서 검색을 해보니 예전에 @aer0 님께서 작성하신 블로그 기사가 있군요.</p>

<ul>
<li><a href="http://aero2blog.blogspot.kr/2010/09/perl-appfatpacker.html">Perl 스크립트에 필요한 모듈 같이 넣기 App::FatPacker</a></li>
</ul>


<p>덩달아서 같이 참고하시면 좋을 것 같습니다.</p>
]]></content>
  </entry>
  
</feed>
