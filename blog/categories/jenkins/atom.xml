<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jenkins | Jeen - Yet anothere techlog]]></title>
  <link href="http://jeen.github.io/blog/categories/jenkins/atom.xml" rel="self"/>
  <link href="http://jeen.github.io/"/>
  <updated>2013-07-18T22:39:38+09:00</updated>
  <id>http://jeen.github.io/</id>
  <author>
    <name><![CDATA[Jeen Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apply MoeEmotional Hudson Plugin on Jenkins]]></title>
    <link href="http://jeen.github.io/2013/07/10/apply-moeemotional-hudson-plugin-on-jenkins/"/>
    <updated>2013-07-10T22:28:59+09:00</updated>
    <id>http://jeen.github.io/2013/07/10/apply-moeemotional-hudson-plugin-on-jenkins</id>
    <content type="html"><![CDATA[<blockquote class="twitter-tweet"><p>젠킨스에서 대머리 아저씨 얼굴 보기가 싫어서, 급하게 테마 하나 제작했습니다. <a href="https://t.co/FcNPdqMjlO">https://t.co/FcNPdqMjlO</a> 앞으로 플랫플랫하게 해볼 예정.</p>&mdash; Park Hyun-woo (@lqez) <a href="https://twitter.com/lqez/statuses/354925228079579138">July 10, 2013</a></blockquote>


<script async src="http://jeen.github.io//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p> 이 모든 원인은 @lqez 님의 트윗에서 시작했습니다.</p>

<p> 이 트윗을 보고 예전에&hellip; 그러니까 일본에서 일하고 있을 당시 CI 에는 별로 신경도 쓰지도 않던 시절에 Hatena bookmark 에서 모에짙은 플러그인에 대한 기사를 떠올렸습니다.</p>

<ul>
<li><a href="http://d.hatena.ne.jp/kanu-orz/20090803/1249225200">Hudsonの萌え化、もしくは痛Hudson化</a></li>
</ul>


<p>　그러니까 당시 Jenkins 가 Hudson 이던 시절에 수염난 아저씨를 눈뜨고 쳐다볼 수 없었던 Hudson 사용자들은 <code>moeemotional-hudson</code> 이라는 플러그인을 만들어 냅니다.
　그와 관련된 링크는 아래와 같습니다.</p>

<ul>
<li><a href="http://d.hatena.ne.jp/torazuka/20090731/1248970549">hud子「継続的インテグレーションを、あなたに」</a></li>
<li><a href="http://d.hatena.ne.jp/torazuka/20090802/hudmis">RED_LAMP用のhud美を追加</a></li>
<li><a href="http://d.hatena.ne.jp/kanu-orz/20090802/1249182957">萌えよHudson(hud子バージョン公開)</a></li>
</ul>


<p> 그리고 모에말고 일반적인 Emotional Jenkins 플러그인도 존재합니다. &ndash;_&ndash;;</p>

<ul>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Emotional+Jenkins+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/Emotional+Jenkins+Plugin</a></li>
</ul>


<p> 뭐 결론은 Stable, Unstable 에 따라서 각각의 상황에 맞는 그림을 대신 표시해주는 것이지요.</p>

<blockquote class="twitter-tweet"><p>그러니까 그런 노력의 결과로... 이런 아저씨가... <a href="http://t.co/1d1TuMWbJs">pic.twitter.com/1d1TuMWbJs</a></p>&mdash; JEEN (@JEEN_LEE) <a href="https://twitter.com/JEEN_LEE/statuses/354939083795083265">July 10, 2013</a></blockquote>




<blockquote class="twitter-tweet"><p>이런 OL 이 된다는 것입니다. <a href="http://t.co/c3Wu2plYAT">pic.twitter.com/c3Wu2plYAT</a></p>&mdash; JEEN (@JEEN_LEE) <a href="https://twitter.com/JEEN_LEE/statuses/354939140883742720">July 10, 2013</a></blockquote>


<p> 이 플러그인은 각 Job 단위로 설정이 가능합니다. 플러그인을 설치하고 post-build action 에서 Moeemotional Hudson 을 추가해줍니다. <strike>그러니까 Job 단위로 설정이 가능한게 Job A 페이지에서만 표시되고 해당 Job 의 빌드 결과에 따른 그림변화는 없었습니다.</strike> 아&hellip; 캐쉬에 의한 착각이었습니다. 각 빌드 페이지에서도 정상적으로 출력됩니다.</p>

<p> 아무튼 플랫플랫하게 나올 결과물을 기대해봅니다.</p>

<ul>
<li><a href="https://github.com/lqez/flat-jenkins">Github &ndash; lqez/flat-jenkins</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl and Continuous Integration with Jenkins - II]]></title>
    <link href="http://jeen.github.io/2012/02/02/perl-and-continuous-integration-with-jenkins-2/"/>
    <updated>2012-02-02T07:00:00+09:00</updated>
    <id>http://jeen.github.io/2012/02/02/perl-and-continuous-integration-with-jenkins-2</id>
    <content type="html"><![CDATA[<p>  애시당초 블로깅하려던 내용을 발표자료로 엮었습니다.</p>

<script src="http://storify.com/jeen_lee/perl-and-continuous-integration-w-jenkins.js"></script>


<p><noscript>[<a href="http://storify.com/jeen_lee/perl-and-continuous-integration-w-jenkins" target="_blank">View the story &ldquo;Perl and Continuous Integration w/ Jenkins&rdquo; on Storify</a>]</noscript></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test::More - use 'subtest' instead of {} block]]></title>
    <link href="http://jeen.github.io/2012/01/05/test-more-use-subtest-instead-of-block/"/>
    <updated>2012-01-05T20:33:00+09:00</updated>
    <id>http://jeen.github.io/2012/01/05/test-more-use-subtest-instead-of-block</id>
    <content type="html"><![CDATA[<p>  여태껏 테스트코드를 써나가면서 그냥 {} 블록안에 일정한 흐름의 테스트 코드를 적곤 했었습니다.</p>

<p>~~~ perl
use Test::More;
use <a href="HTTP::Request::Common;">HTTP::Request::Common;</a>
use Catalyst::Test &lsquo;MyApp::Web&rsquo;;</p>

<p># Access /
{</p>

<pre><code>my $res = request('/');
ok($res-&gt;is_success, "Request should be succeed");
ok($res-&gt;header('.......'), 'Header xxxxx exist');
like($res-&gt;content, qr|some sentences|, "Found some sentences")
</code></pre>

<p>}</p>

<p># Login
{</p>

<pre><code>my $req = POST('/login', \[ 'username' =&gt; 'blahblah', 'password' =&gt; 'blahblah' \]);
my $res = request($req);
ok($res-&gt;is_success, "Request should be suceed");
....
</code></pre>

<p>}</p>

<p># some action
{</p>

<pre><code>...;
</code></pre>

<p>}
~~~</p>

<p>  일단 뭐 {} 블록으로 각 action 에 대한 접근결과를 테스트하고, <code>#</code> 로 주석표시를 하면서 하나둘 하나둘 각 블록에 <code>$req</code>, <code>$res</code> 를 추가했었습니다. 일단 뭐 {} 블록으로 묶으면서 <code>$req</code>, <code>$res</code> 따위의 변수의 재정의 등에 관한 경고같은 것이 안나와서 좋고, 제대로 분류가 되는 느낌이기도 했습니다.</p>

<h3>그냥 <code>subtest</code> 를 사용하면 어떨까?</h3>

<p>  그러는 도중에 <a href="http://search.cpan.org/perldoc?Test::More">Test::More 매뉴얼</a>을 읽어보다가 <code>subtest</code> 를 사용할 수 있다는 것을 알게 되었습니다.</p>

<p>~~~ perl
use <a href="HTTP::Request::Common;">HTTP::Request::Common;</a>
use Catalyst::Test &lsquo;MyApp::Web&rsquo;;
use Test::More;</p>

<p>subtest &lsquo;access to /&rsquo; => sub {</p>

<pre><code>my $res = request('/');
ok($res-&gt;is_success, "Request should be succeed");
ok($res-&gt;header('.......'), 'Header xxxxx exist');
like($res-&gt;content, qr|some sentences|, "Found some sentences")
</code></pre>

<p>};</p>

<p>subtest &lsquo;Login&rsquo; => sub {</p>

<pre><code>my $req = POST('/login', \[ 'username' =&gt; 'blahblah', 'password' =&gt; 'blahblah' \]);
my $res = request($req);
ok($res-&gt;is_success, "Request should be suceed");
....
</code></pre>

<p>};
~~~</p>

<p>  <code>subtest</code> 를 사용하면서 코드는 위처럼 바뀌었습니다. <code>#</code> 로 주석처리를 할 필요도 없고, 해당 <code>subtest</code> 마다 명확하게 무엇을 하는 지 확실하게 의미있는 <code>subtest</code> 의 이름으로 정해줄 수 있었습니다.</p>

<p>  <code>subtest</code> 로 테스트를 썼을 경우는 TAP 결과는 다음과 같습니다.</p>

<p>~~~ bash
$ prove t/myapp.t
ok 1 &ndash; access to /</p>

<pre><code>ok 1 - Request should be succeed
ok 2 - Header xxxxx exist
ok 3 - Found some sentences
1..3
</code></pre>

<p>ok 2 &ndash; Login</p>

<pre><code>ok 1 - Request should be suceed
...
1..3
</code></pre>

<p>&hellip;.
1..3
ok
All tests successful.
Files=1, Tests=3, 10 wallclock secs ( 0.07 usr  0.01 sys +  6.16 cusr  0.61 csys =  6.85 CPU)
Result: PASS
~~~</p>

<p>  전체 테스트 횟수는 <code>subtest</code> 안의 테스트 항목이 아니라, <code>subtest</code> 의 갯수가 되는 것입니다.</p>

<p>  그리고 <code>subtest</code> 를 사용하지 않고 {} 블록을 이용해서 flat 하게 정의했을 때는 아래와 같습니다.</p>

<p><del> bash
&hellip;
ok 1 &ndash; Request should be succeed
ok 2 &ndash; Header xxxxx exist
ok 3 &ndash; Found some sentences
ok 4 &ndash; Request should be suceed
 &hellip;
</del></p>

<p>  테스트 항목 1,4 번의 메시지가 같기 때문에 매번 달리 지정해줘야 되는 수고가 발생하죠. 그리고 각각의 테스트 항목 하나하나가 테스트 갯수가 되는 것입니다.</p>

<p>  사실은 위의 Jenkins 상의 <code>Test Result Trend</code> 의 그래프가 어느 순간 갑자기 뚝 떨어지길래, 어라 이상하다 싶어서 살펴본 결과, <code>subtest</code> 기준으로 카운트되어있는 것을 확인했습니다.</p>

<p><img src="https://lh5.googleusercontent.com/-TSX-Kd5-fX4/TwWRjvHx2LI/AAAAAAAAA94/pYrEEgHBZic/test-result-trend.png" alt="Jenkins Test Result Trend 의 낙폭" /></p>

<p>  대충 위의 <code>#58</code> 번 빌드가 그 쯤이 되겠네요.</p>

<p>  아무튼 Jenkins 도입이후에 좀 더 테스트코드에 더 신경을 쓰고 있는 요즘입니다.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perl and Continuous Integration with Jenkins - I]]></title>
    <link href="http://jeen.github.io/2012/01/03/perl-and-continuous-integration-with-jenkins-1/"/>
    <updated>2012-01-03T11:45:00+09:00</updated>
    <id>http://jeen.github.io/2012/01/03/perl-and-continuous-integration-with-jenkins-1</id>
    <content type="html"><![CDATA[<h3>Jenkins 를 사용하기 까지</h3>

<p>사실 지난주에 NHN 에서 주최하는 공개개발자 교육에  갔다왔었습니다. 평소 Jenkins 에 대해서 약간 환상 같은 게 있다고 할까, 필요성이 있다고 할까요. 좀 더 프로젝트의 품질이 나아지고 있다는 환상, 그런 걸 보면서 나름 보람을 느끼고 싶다라는 생각도 있었습니다.</p>

<p>아무튼 Jenkins 교육은 Java 위주의 프로젝트에 적용하는 얘기였지만, 다른 언어에서도 충분히 지원된다라는 얘기를 익히들어왔기에 대강 실습을 따라하면서 감을 익히고 회사에 와서 본격적으로 Jenkins 를 만지기 시작했습니다.</p>

<h3>Perl &amp; Jenkins</h3>

<p>Jenkins 교육에서는 Maven 을 위주로 여러가지 옵션(?) 을 추가하는 것으로 간단하게 각종 Report 를 뽑아내기 위한 xml 들을 생성할 수 있었습니다. 아쉽게도 Perl 로는 Maven 만큼 쉽게 그렇게 만들기는 어려웠지요.</p>

<p>일단 Perl 에는 기본적으로 TAP 형식을 따르고 있기 때문에 Java 류의 JUnit 으로 결과를 뽑아낼 필요가 있었습니다. 그래서 TAP 를 JUnit 으로 쉽게 바꿔줄 수 있는 방법이 필요했죠.</p>

<p><del> bash
$ prove &mdash;formatter &mdash;timer TAP::Formatter::JUnit t
</del></p>

<p>위와 같은 형식으로 <code>t</code> 디렉토리 아래의 테스트파일들을 테스트하며 결과는 <code>TAP::Formatter::JUnit</code> 에 의해서 xml 파일로 나오게 됩니다.</p>

<p>~~~ xml
<testsuites>
  &lt;testsuite failures=&ldquo;0&rdquo;</p>

<pre><code>         errors="0"
         time="25.6525909900665"
         tests="1"
         name="Catalyst_controller_Admin-Activity_t"&gt;
&lt;testcase time="0"
          name="1 - Request should succeed"&gt;&lt;/testcase&gt;
&lt;system-out&gt;&lt;![CDATA[ok 1 - Request should succeed
</code></pre>

<p>1..1
]]&gt;&lt;/system-out></p>

<pre><code>&lt;system-err&gt;&lt;/system-err&gt;
&lt;/testsuite&gt;
</code></pre>

<p></testsuites>
~~~</p>

<h3>Task::Jenkins</h3>

<p>사실은 Jenkins 에서 Perl 프로젝트를 올릴 때의 주요한 모듈의 묶음은 <a href="http://search.cpan.org/perldoc?Task::Jenkins">Task::Jenkins</a> 모듈로 제공되고 있습니다. Task::Jenkins 에 있는 모듈들은,</p>

<ul>
<li><a href="http://search.cpan.org/perldoc?TAP::Formatter::JUnit">TAP::Formatter::JUnit</a></li>
<li><a href="http://search.cpan.org/perldoc?App::Prove">App::Prove</a></li>
<li><a href="http://search.cpan.org/perldoc?Devel::Cover">Devel::Cover</a></li>
</ul>


<p>입니다.</p>

<p><code>TAP::Formatter::JUnit</code> 의 경우는 위에서 설명했고, <code>App::Prove</code> 는 위의 테스트코드를 실행하는 커맨드인 <code>prove</code> 를 사용하기 위한 모듈입니다. <code>Devel::Cover</code> 는 Code Coverage 를 확인할 수 있는 모듈이구요.</p>

<p>일단 Jenkins 에서 Perl 프로젝트를 적용하는 준비는 기본적으로 위의 <code>Task::Jenkins</code> 를 설치함으로 어느 정도 끝났다고 볼 수 있습니다.</p>

<h3>Jenkins 설치</h3>

<p>회사내의 서버에 Jenkins 를 설치했습니다. Ubuntu 10.10 Server 버젼이며, Jenkins 의 설치는 그렇게 어렵지 않습니다.</p>

<p>쉽게 Google 에서 <em>Jenkins Ubuntu</em> 로 검색해서 나온 것들 중 첫번째를 골라봤습니다.</p>

<ul>
<li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">Installing Jenkins on Ubuntu</a></li>
</ul>


<p><code>apt</code> source 추가하고 <code>aptitude</code> 로 설치하고, Apache 에서 Proxy 설정해주고, 이에 대한 자세한 이야기는 위의 링크에 자세히 나와 있으니 참고하시길 바랍니다.</p>

<p>NHN 공개개발자 교육에서는 보안상의 문제로 Tomcat 위에다가 얹어놓기를 권하셨지만, Jenkins 자체의 Standalone Server 로 충분하지 않나 생각됩니다. 뭐 어차피 사내 네트워크 안에서 사용할 것인데&hellip; 라며&hellip; =3</p>

<p>아무튼 이렇게 띄워서 실제로 사내에서 사용하고 있는 Jenkins Top Page 는 아래와 같습니다.</p>

<p><img src="http://lh6.googleusercontent.com/--lGDWehSz5k/TwKGZAtvsUI/AAAAAAAAA9w/tRFttK10-wg/jenkins-top-page.png" alt="Jenkins Top" /></p>

<p>한번에 적으려니 좀 길고 해서, 일단 밑밥깔기부터 하고 다음 글부터는 좀 더 자세한 Jenkins 에서 Perl 프로젝트 적용에 대해서 상세한 캡쳐와 함께 설명하고자 합니다.</p>
]]></content>
  </entry>
  
</feed>
